KEVM Optimizations
==================

These optimizations work on the LLVM and Haskell backend and are generated by the script `./optimizer/optimizations.sh`.

```k
requires "evm.md"
requires "lemmas/int-simplification.k"

module EVM-OPTIMIZATIONS-LEMMAS [symbolic]
    imports EVM

    rule #sizeWordStack(WS [ I := _ ]) => #sizeWordStack(WS, N) requires I <Int #sizeWordStack(WS) [simplification]
    rule 0 <=Int #sizeWordStack(_)     => true                                                     [simplification, smt-lemma]
    rule #sizeWordStack(_) <Int N      => false                 requires N <=Int 0                 [simplification, smt-lemma]

endmodule

module EVM-OPTIMIZATIONS
    imports EVM
    imports EVM-OPTIMIZATIONS-LEMMAS
    imports INT-SIMPLIFICATION


    claim
    [optimized.add]:
      <kevm>
        <k>
          ( #next[ ADD ] => .K ) ...
        </k>
        <schedule>
          SCHED
        </schedule>
        <useGas>
          USEGAS
        </useGas>
        <ethereum>
          <evm>
            <callState>
              <wordStack>
                ( W0 : W1 : WS => chop( ( W0 +Int W1 ) ) : WS )
              </wordStack>
              <pc>
                ( PCOUNT => ( PCOUNT +Int 1 ) )
              </pc>
              <gas>
                ( GAVAIL => #if USEGAS #then ( GAVAIL -Gas Gverylow < SCHED > ) #else GAVAIL #fi )
              </gas>
              ...
            </callState>
            ...
          </evm>
          ...
        </ethereum>
        ...
      </kevm>
      requires ( #if USEGAS #then Gverylow < SCHED > <=Gas GAVAIL #else true #fi )
      andBool ( #sizeWordStack( WS ) <=Int 1023 )

endmodule
```
