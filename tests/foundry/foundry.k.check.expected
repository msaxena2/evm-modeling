requires "foundry.md"

module ACCOUNTPARAMSTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= AccountParamsTestContract
    
    syntax AccountParamsTestContract ::= "AccountParamsTest" [symbol(), klabel(contract_AccountParamsTest)]
    
      
    
    syntax Field ::= AccountParamsTestField
    
    syntax AccountParamsTestField ::= "IS_TEST" [symbol(), klabel(field_AccountParamsTest_IS_TEST)]
    
    syntax AccountParamsTestField ::= "_failed" [symbol(), klabel(field_AccountParamsTest__failed)]
    
    syntax AccountParamsTestField ::= "IS_SCRIPT" [symbol(), klabel(field_AccountParamsTest_IS_SCRIPT)]
    
    syntax AccountParamsTestField ::= "stdstore" [symbol(), klabel(field_AccountParamsTest_stdstore)]
    
    rule  ( #loc ( AccountParamsTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( AccountParamsTest . _failed ) => 0 )
      
    
    rule  ( #loc ( AccountParamsTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( AccountParamsTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= AccountParamsTestContract "." AccountParamsTestMethod [function(), symbol(), klabel(method_AccountParamsTest)]
    
    syntax AccountParamsTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_AccountParamsTest_IS_SCRIPT)]
    
    syntax AccountParamsTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_AccountParamsTest_IS_TEST)]
    
    syntax AccountParamsTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_AccountParamsTest_failed)]
    
    syntax AccountParamsTestMethod ::= "testDealConcrete" "(" ")" [symbol(), klabel(method_AccountParamsTest_testDealConcrete)]
    
    syntax AccountParamsTestMethod ::= "testDealSymbolic" "(" Int ")" [symbol(), klabel(method_AccountParamsTest_testDealSymbolic)]
    
    syntax AccountParamsTestMethod ::= "testEtchConcrete" "(" ")" [symbol(), klabel(method_AccountParamsTest_testEtchConcrete)]
    
    syntax AccountParamsTestMethod ::= "testEtchSymbolic" "(" Bytes ")" [symbol(), klabel(method_AccountParamsTest_testEtchSymbolic)]
    
    syntax AccountParamsTestMethod ::= "testFail_GetNonce_false" "(" ")" [symbol(), klabel(method_AccountParamsTest_testFail_GetNonce_false)]
    
    syntax AccountParamsTestMethod ::= "testFail_GetNonce_true" "(" ")" [symbol(), klabel(method_AccountParamsTest_testFail_GetNonce_true)]
    
    syntax AccountParamsTestMethod ::= "testNonceSymbolic" "(" Int ")" [symbol(), klabel(method_AccountParamsTest_testNonceSymbolic)]
    
    syntax AccountParamsTestMethod ::= "test_GetNonce_false" "(" ")" [symbol(), klabel(method_AccountParamsTest_test_GetNonce_false)]
    
    syntax AccountParamsTestMethod ::= "test_GetNonce_true" "(" ")" [symbol(), klabel(method_AccountParamsTest_test_GetNonce_true)]
    
    syntax AccountParamsTestMethod ::= "test_Nonce_ExistentAddress" "(" ")" [symbol(), klabel(method_AccountParamsTest_test_Nonce_ExistentAddress)]
    
    syntax AccountParamsTestMethod ::= "test_Nonce_NonExistentAddress" "(" ")" [symbol(), klabel(method_AccountParamsTest_test_Nonce_NonExistentAddress)]
    
    syntax AccountParamsTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_AccountParamsTest_vm)]
    
    rule  ( AccountParamsTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( AccountParamsTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( AccountParamsTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( AccountParamsTest . testDealConcrete ( ) => #abiCallData ( "testDealConcrete" , .TypedArgs ) )
      
    
    rule  ( AccountParamsTest . testDealSymbolic ( V0_value ) => #abiCallData ( "testDealSymbolic" , #uint256 ( V0_value ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_value )
      
    
    rule  ( AccountParamsTest . testEtchConcrete ( ) => #abiCallData ( "testEtchConcrete" , .TypedArgs ) )
      
    
    rule  ( AccountParamsTest . testEtchSymbolic ( V0_code ) => #abiCallData ( "testEtchSymbolic" , #bytes ( V0_code ) , .TypedArgs ) )
       ensures #rangeUInt ( 128 , lengthBytes ( V0_code ) )
      
    
    rule  ( AccountParamsTest . testFail_GetNonce_false ( ) => #abiCallData ( "testFail_GetNonce_false" , .TypedArgs ) )
      
    
    rule  ( AccountParamsTest . testFail_GetNonce_true ( ) => #abiCallData ( "testFail_GetNonce_true" , .TypedArgs ) )
      
    
    rule  ( AccountParamsTest . testNonceSymbolic ( V0_newNonce ) => #abiCallData ( "testNonceSymbolic" , #uint64 ( V0_newNonce ) , .TypedArgs ) )
       ensures #rangeUInt ( 64 , V0_newNonce )
      
    
    rule  ( AccountParamsTest . test_GetNonce_false ( ) => #abiCallData ( "test_GetNonce_false" , .TypedArgs ) )
      
    
    rule  ( AccountParamsTest . test_GetNonce_true ( ) => #abiCallData ( "test_GetNonce_true" , .TypedArgs ) )
      
    
    rule  ( AccountParamsTest . test_Nonce_ExistentAddress ( ) => #abiCallData ( "test_Nonce_ExistentAddress" , .TypedArgs ) )
      
    
    rule  ( AccountParamsTest . test_Nonce_NonExistentAddress ( ) => #abiCallData ( "test_Nonce_NonExistentAddress" , .TypedArgs ) )
      
    
    rule  ( AccountParamsTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testDealConcrete" ) => 530093250 )
      
    
    rule  ( selector ( "testDealSymbolic" ) => 2584982624 )
      
    
    rule  ( selector ( "testEtchConcrete" ) => 807503996 )
      
    
    rule  ( selector ( "testEtchSymbolic" ) => 2109411263 )
      
    
    rule  ( selector ( "testFail_GetNonce_false" ) => 2393877859 )
      
    
    rule  ( selector ( "testFail_GetNonce_true" ) => 1067907152 )
      
    
    rule  ( selector ( "testNonceSymbolic" ) => 1310260491 )
      
    
    rule  ( selector ( "test_GetNonce_false" ) => 3545243759 )
      
    
    rule  ( selector ( "test_GetNonce_true" ) => 3968101798 )
      
    
    rule  ( selector ( "test_Nonce_ExistentAddress" ) => 1598387740 )
      
    
    rule  ( selector ( "test_Nonce_NonExistentAddress" ) => 2985064833 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module ADDRTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= AddrTestContract
    
    syntax AddrTestContract ::= "AddrTest" [symbol(), klabel(contract_AddrTest)]
    
      
    
    syntax Field ::= AddrTestField
    
    syntax AddrTestField ::= "IS_TEST" [symbol(), klabel(field_AddrTest_IS_TEST)]
    
    syntax AddrTestField ::= "_failed" [symbol(), klabel(field_AddrTest__failed)]
    
    syntax AddrTestField ::= "IS_SCRIPT" [symbol(), klabel(field_AddrTest_IS_SCRIPT)]
    
    syntax AddrTestField ::= "stdstore" [symbol(), klabel(field_AddrTest_stdstore)]
    
    rule  ( #loc ( AddrTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( AddrTest . _failed ) => 0 )
      
    
    rule  ( #loc ( AddrTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( AddrTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= AddrTestContract "." AddrTestMethod [function(), symbol(), klabel(method_AddrTest)]
    
    syntax AddrTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_AddrTest_IS_SCRIPT)]
    
    syntax AddrTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_AddrTest_IS_TEST)]
    
    syntax AddrTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_AddrTest_failed)]
    
    syntax AddrTestMethod ::= "kevm" "(" ")" [symbol(), klabel(method_AddrTest_kevm)]
    
    syntax AddrTestMethod ::= "testFail_addr_false" "(" ")" [symbol(), klabel(method_AddrTest_testFail_addr_false)]
    
    syntax AddrTestMethod ::= "testFail_addr_true" "(" ")" [symbol(), klabel(method_AddrTest_testFail_addr_true)]
    
    syntax AddrTestMethod ::= "test_addr_false" "(" ")" [symbol(), klabel(method_AddrTest_test_addr_false)]
    
    syntax AddrTestMethod ::= "test_addr_symbolic" "(" Int ")" [symbol(), klabel(method_AddrTest_test_addr_symbolic)]
    
    syntax AddrTestMethod ::= "test_addr_true" "(" ")" [symbol(), klabel(method_AddrTest_test_addr_true)]
    
    syntax AddrTestMethod ::= "test_builtInAddresses" "(" ")" [symbol(), klabel(method_AddrTest_test_builtInAddresses)]
    
    syntax AddrTestMethod ::= "test_notBuiltinAddress_concrete" "(" ")" [symbol(), klabel(method_AddrTest_test_notBuiltinAddress_concrete)]
    
    syntax AddrTestMethod ::= "test_notBuiltinAddress_symbolic" "(" Int ")" [symbol(), klabel(method_AddrTest_test_notBuiltinAddress_symbolic)]
    
    syntax AddrTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_AddrTest_vm)]
    
    rule  ( AddrTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( AddrTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( AddrTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( AddrTest . kevm ( ) => #abiCallData ( "kevm" , .TypedArgs ) )
      
    
    rule  ( AddrTest . testFail_addr_false ( ) => #abiCallData ( "testFail_addr_false" , .TypedArgs ) )
      
    
    rule  ( AddrTest . testFail_addr_true ( ) => #abiCallData ( "testFail_addr_true" , .TypedArgs ) )
      
    
    rule  ( AddrTest . test_addr_false ( ) => #abiCallData ( "test_addr_false" , .TypedArgs ) )
      
    
    rule  ( AddrTest . test_addr_symbolic ( V0_pk ) => #abiCallData ( "test_addr_symbolic" , #uint256 ( V0_pk ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_pk )
      
    
    rule  ( AddrTest . test_addr_true ( ) => #abiCallData ( "test_addr_true" , .TypedArgs ) )
      
    
    rule  ( AddrTest . test_builtInAddresses ( ) => #abiCallData ( "test_builtInAddresses" , .TypedArgs ) )
      
    
    rule  ( AddrTest . test_notBuiltinAddress_concrete ( ) => #abiCallData ( "test_notBuiltinAddress_concrete" , .TypedArgs ) )
      
    
    rule  ( AddrTest . test_notBuiltinAddress_symbolic ( V0_addr ) => #abiCallData ( "test_notBuiltinAddress_symbolic" , #address ( V0_addr ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_addr )
      
    
    rule  ( AddrTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "kevm" ) => 3601001590 )
      
    
    rule  ( selector ( "testFail_addr_false" ) => 3302866643 )
      
    
    rule  ( selector ( "testFail_addr_true" ) => 2486005453 )
      
    
    rule  ( selector ( "test_addr_false" ) => 4124294109 )
      
    
    rule  ( selector ( "test_addr_symbolic" ) => 3071220939 )
      
    
    rule  ( selector ( "test_addr_true" ) => 809049819 )
      
    
    rule  ( selector ( "test_builtInAddresses" ) => 3220291840 )
      
    
    rule  ( selector ( "test_notBuiltinAddress_concrete" ) => 2409208231 )
      
    
    rule  ( selector ( "test_notBuiltinAddress_symbolic" ) => 2160641203 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module ALLOWCHANGESTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= AllowChangesTestContract
    
    syntax AllowChangesTestContract ::= "AllowChangesTest" [symbol(), klabel(contract_AllowChangesTest)]
    
      
    
    syntax Field ::= AllowChangesTestField
    
    syntax AllowChangesTestField ::= "IS_TEST" [symbol(), klabel(field_AllowChangesTest_IS_TEST)]
    
    syntax AllowChangesTestField ::= "_failed" [symbol(), klabel(field_AllowChangesTest__failed)]
    
    syntax AllowChangesTestField ::= "IS_SCRIPT" [symbol(), klabel(field_AllowChangesTest_IS_SCRIPT)]
    
    syntax AllowChangesTestField ::= "stdstore" [symbol(), klabel(field_AllowChangesTest_stdstore)]
    
    rule  ( #loc ( AllowChangesTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( AllowChangesTest . _failed ) => 0 )
      
    
    rule  ( #loc ( AllowChangesTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( AllowChangesTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= AllowChangesTestContract "." AllowChangesTestMethod [function(), symbol(), klabel(method_AllowChangesTest)]
    
    syntax AllowChangesTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_AllowChangesTest_IS_SCRIPT)]
    
    syntax AllowChangesTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_AllowChangesTest_IS_TEST)]
    
    syntax AllowChangesTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_AllowChangesTest_failed)]
    
    syntax AllowChangesTestMethod ::= "kevm" "(" ")" [symbol(), klabel(method_AllowChangesTest_kevm)]
    
    syntax AllowChangesTestMethod ::= "test" "(" ")" [symbol(), klabel(method_AllowChangesTest_test)]
    
    syntax AllowChangesTestMethod ::= "testAllow" "(" ")" [symbol(), klabel(method_AllowChangesTest_testAllow)]
    
    syntax AllowChangesTestMethod ::= "testAllow_fail" "(" ")" [symbol(), klabel(method_AllowChangesTest_testAllow_fail)]
    
    syntax AllowChangesTestMethod ::= "testFailAllowCallsToAddress" "(" ")" [symbol(), klabel(method_AllowChangesTest_testFailAllowCallsToAddress)]
    
    syntax AllowChangesTestMethod ::= "testFailAllowChangesToStorage" "(" ")" [symbol(), klabel(method_AllowChangesTest_testFailAllowChangesToStorage)]
    
    syntax AllowChangesTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_AllowChangesTest_vm)]
    
    rule  ( AllowChangesTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( AllowChangesTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( AllowChangesTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( AllowChangesTest . kevm ( ) => #abiCallData ( "kevm" , .TypedArgs ) )
      
    
    rule  ( AllowChangesTest . test ( ) => #abiCallData ( "test" , .TypedArgs ) )
      
    
    rule  ( AllowChangesTest . testAllow ( ) => #abiCallData ( "testAllow" , .TypedArgs ) )
      
    
    rule  ( AllowChangesTest . testAllow_fail ( ) => #abiCallData ( "testAllow_fail" , .TypedArgs ) )
      
    
    rule  ( AllowChangesTest . testFailAllowCallsToAddress ( ) => #abiCallData ( "testFailAllowCallsToAddress" , .TypedArgs ) )
      
    
    rule  ( AllowChangesTest . testFailAllowChangesToStorage ( ) => #abiCallData ( "testFailAllowChangesToStorage" , .TypedArgs ) )
      
    
    rule  ( AllowChangesTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "kevm" ) => 3601001590 )
      
    
    rule  ( selector ( "test" ) => 4171824493 )
      
    
    rule  ( selector ( "testAllow" ) => 3693132891 )
      
    
    rule  ( selector ( "testAllow_fail" ) => 4129570225 )
      
    
    rule  ( selector ( "testFailAllowCallsToAddress" ) => 1262828121 )
      
    
    rule  ( selector ( "testFailAllowChangesToStorage" ) => 1529992487 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module VALUESTORE-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ValueStoreContract
    
    syntax ValueStoreContract ::= "ValueStore" [symbol(), klabel(contract_ValueStore)]
    
      
    
    syntax Field ::= ValueStoreField
    
    syntax ValueStoreField ::= "value1" [symbol(), klabel(field_ValueStore_value1)]
    
    syntax ValueStoreField ::= "value2" [symbol(), klabel(field_ValueStore_value2)]
    
    rule  ( #loc ( ValueStore . value1 ) => 0 )
      
    
    rule  ( #loc ( ValueStore . value2 ) => 1 )
      
    
    syntax Bytes ::= ValueStoreContract "." ValueStoreMethod [function(), symbol(), klabel(method_ValueStore)]
    
    syntax ValueStoreMethod ::= "changeValue1" "(" Int ")" [symbol(), klabel(method_ValueStore_changeValue1)]
    
    syntax ValueStoreMethod ::= "changeValue2" "(" Int ")" [symbol(), klabel(method_ValueStore_changeValue2)]
    
    syntax ValueStoreMethod ::= "value1" "(" ")" [symbol(), klabel(method_ValueStore_value1)]
    
    syntax ValueStoreMethod ::= "value2" "(" ")" [symbol(), klabel(method_ValueStore_value2)]
    
    rule  ( ValueStore . changeValue1 ( V0_newValue ) => #abiCallData ( "changeValue1" , #uint256 ( V0_newValue ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_newValue )
      
    
    rule  ( ValueStore . changeValue2 ( V0_newValue ) => #abiCallData ( "changeValue2" , #uint256 ( V0_newValue ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_newValue )
      
    
    rule  ( ValueStore . value1 ( ) => #abiCallData ( "value1" , .TypedArgs ) )
      
    
    rule  ( ValueStore . value2 ( ) => #abiCallData ( "value2" , .TypedArgs ) )
      
    
    rule  ( selector ( "changeValue1" ) => 1634438405 )
      
    
    rule  ( selector ( "changeValue2" ) => 367426214 )
      
    
    rule  ( selector ( "value1" ) => 808665403 )
      
    
    rule  ( selector ( "value2" ) => 1563665023 )
      

endmodule

module ARITHMETICTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ArithmeticTestContract
    
    syntax ArithmeticTestContract ::= "ArithmeticTest" [symbol(), klabel(contract_ArithmeticTest)]
    
      
    
    syntax Field ::= ArithmeticTestField
    
    syntax ArithmeticTestField ::= "IS_TEST" [symbol(), klabel(field_ArithmeticTest_IS_TEST)]
    
    syntax ArithmeticTestField ::= "_failed" [symbol(), klabel(field_ArithmeticTest__failed)]
    
    syntax ArithmeticTestField ::= "IS_SCRIPT" [symbol(), klabel(field_ArithmeticTest_IS_SCRIPT)]
    
    syntax ArithmeticTestField ::= "stdstore" [symbol(), klabel(field_ArithmeticTest_stdstore)]
    
    rule  ( #loc ( ArithmeticTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( ArithmeticTest . _failed ) => 0 )
      
    
    rule  ( #loc ( ArithmeticTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( ArithmeticTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= ArithmeticTestContract "." ArithmeticTestMethod [function(), symbol(), klabel(method_ArithmeticTest)]
    
    syntax ArithmeticTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_ArithmeticTest_IS_SCRIPT)]
    
    syntax ArithmeticTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_ArithmeticTest_IS_TEST)]
    
    syntax ArithmeticTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_ArithmeticTest_failed)]
    
    syntax ArithmeticTestMethod ::= "test_decreasing_div" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_decreasing_div)]
    
    syntax ArithmeticTestMethod ::= "test_max1" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_max1)]
    
    syntax ArithmeticTestMethod ::= "test_max1_broken" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_max1_broken)]
    
    syntax ArithmeticTestMethod ::= "test_max2" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_max2)]
    
    syntax ArithmeticTestMethod ::= "test_wdiv_rounding" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_wdiv_rounding)]
    
    syntax ArithmeticTestMethod ::= "test_wmul_increasing" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_wmul_increasing)]
    
    syntax ArithmeticTestMethod ::= "test_wmul_increasing_gt_one" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_wmul_increasing_gt_one)]
    
    syntax ArithmeticTestMethod ::= "test_wmul_increasing_overflow" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_wmul_increasing_overflow)]
    
    syntax ArithmeticTestMethod ::= "test_wmul_increasing_positive" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_wmul_increasing_positive)]
    
    syntax ArithmeticTestMethod ::= "test_wmul_rounding" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_wmul_rounding)]
    
    syntax ArithmeticTestMethod ::= "test_wmul_wdiv_inverse" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_wmul_wdiv_inverse)]
    
    syntax ArithmeticTestMethod ::= "test_wmul_wdiv_inverse_underflow" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_wmul_wdiv_inverse_underflow)]
    
    syntax ArithmeticTestMethod ::= "test_wmul_weakly_increasing_positive" "(" Int "," Int ")" [symbol(), klabel(method_ArithmeticTest_test_wmul_weakly_increasing_positive)]
    
    syntax ArithmeticTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_ArithmeticTest_vm)]
    
    rule  ( ArithmeticTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( ArithmeticTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( ArithmeticTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( ArithmeticTest . test_decreasing_div ( V0_a , V1_b ) => #abiCallData ( "test_decreasing_div" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( ArithmeticTest . test_max1 ( V0_a , V1_b ) => #abiCallData ( "test_max1" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( ArithmeticTest . test_max1_broken ( V0_a , V1_b ) => #abiCallData ( "test_max1_broken" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( ArithmeticTest . test_max2 ( V0_x , V1_y ) => #abiCallData ( "test_max2" , #uint256 ( V0_x ) , #uint256 ( V1_y ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_x )
       andBool ( #rangeUInt ( 256 , V1_y )
               ))
      
    
    rule  ( ArithmeticTest . test_wdiv_rounding ( V0_a , V1_b ) => #abiCallData ( "test_wdiv_rounding" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( ArithmeticTest . test_wmul_increasing ( V0_a , V1_b ) => #abiCallData ( "test_wmul_increasing" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( ArithmeticTest . test_wmul_increasing_gt_one ( V0_a , V1_b ) => #abiCallData ( "test_wmul_increasing_gt_one" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( ArithmeticTest . test_wmul_increasing_overflow ( V0_a , V1_b ) => #abiCallData ( "test_wmul_increasing_overflow" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( ArithmeticTest . test_wmul_increasing_positive ( V0_a , V1_b ) => #abiCallData ( "test_wmul_increasing_positive" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( ArithmeticTest . test_wmul_rounding ( V0_a , V1_b ) => #abiCallData ( "test_wmul_rounding" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( ArithmeticTest . test_wmul_wdiv_inverse ( V0_a , V1_b ) => #abiCallData ( "test_wmul_wdiv_inverse" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( ArithmeticTest . test_wmul_wdiv_inverse_underflow ( V0_a , V1_b ) => #abiCallData ( "test_wmul_wdiv_inverse_underflow" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( ArithmeticTest . test_wmul_weakly_increasing_positive ( V0_a , V1_b ) => #abiCallData ( "test_wmul_weakly_increasing_positive" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( ArithmeticTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "test_decreasing_div" ) => 1011519306 )
      
    
    rule  ( selector ( "test_max1" ) => 1625765100 )
      
    
    rule  ( selector ( "test_max1_broken" ) => 2809107068 )
      
    
    rule  ( selector ( "test_max2" ) => 434746443 )
      
    
    rule  ( selector ( "test_wdiv_rounding" ) => 345004095 )
      
    
    rule  ( selector ( "test_wmul_increasing" ) => 2784670501 )
      
    
    rule  ( selector ( "test_wmul_increasing_gt_one" ) => 899022695 )
      
    
    rule  ( selector ( "test_wmul_increasing_overflow" ) => 1123042280 )
      
    
    rule  ( selector ( "test_wmul_increasing_positive" ) => 490103800 )
      
    
    rule  ( selector ( "test_wmul_rounding" ) => 4261140569 )
      
    
    rule  ( selector ( "test_wmul_wdiv_inverse" ) => 3719613508 )
      
    
    rule  ( selector ( "test_wmul_wdiv_inverse_underflow" ) => 2736038219 )
      
    
    rule  ( selector ( "test_wmul_weakly_increasing_positive" ) => 1421647895 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module ASSUMETEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= AssumeTestContract
    
    syntax AssumeTestContract ::= "AssumeTest" [symbol(), klabel(contract_AssumeTest)]
    
      
    
    syntax Field ::= AssumeTestField
    
    syntax AssumeTestField ::= "IS_TEST" [symbol(), klabel(field_AssumeTest_IS_TEST)]
    
    syntax AssumeTestField ::= "_failed" [symbol(), klabel(field_AssumeTest__failed)]
    
    syntax AssumeTestField ::= "IS_SCRIPT" [symbol(), klabel(field_AssumeTest_IS_SCRIPT)]
    
    syntax AssumeTestField ::= "stdstore" [symbol(), klabel(field_AssumeTest_stdstore)]
    
    rule  ( #loc ( AssumeTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( AssumeTest . _failed ) => 0 )
      
    
    rule  ( #loc ( AssumeTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( AssumeTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= AssumeTestContract "." AssumeTestMethod [function(), symbol(), klabel(method_AssumeTest)]
    
    syntax AssumeTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_AssumeTest_IS_SCRIPT)]
    
    syntax AssumeTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_AssumeTest_IS_TEST)]
    
    syntax AssumeTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_AssumeTest_failed)]
    
    syntax AssumeTestMethod ::= "testFail_assume_false" "(" Int "," Int ")" [symbol(), klabel(method_AssumeTest_testFail_assume_false)]
    
    syntax AssumeTestMethod ::= "testFail_assume_true" "(" Int "," Int ")" [symbol(), klabel(method_AssumeTest_testFail_assume_true)]
    
    syntax AssumeTestMethod ::= "test_assume_false" "(" Int "," Int ")" [symbol(), klabel(method_AssumeTest_test_assume_false)]
    
    syntax AssumeTestMethod ::= "test_assume_staticCall" "(" Int ")" [symbol(), klabel(method_AssumeTest_test_assume_staticCall)]
    
    syntax AssumeTestMethod ::= "test_assume_true" "(" Int "," Int ")" [symbol(), klabel(method_AssumeTest_test_assume_true)]
    
    syntax AssumeTestMethod ::= "test_multi_assume" "(" Int "," Int ")" [symbol(), klabel(method_AssumeTest_test_multi_assume)]
    
    syntax AssumeTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_AssumeTest_vm)]
    
    rule  ( AssumeTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( AssumeTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( AssumeTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( AssumeTest . testFail_assume_false ( V0_a , V1_b ) => #abiCallData ( "testFail_assume_false" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( AssumeTest . testFail_assume_true ( V0_a , V1_b ) => #abiCallData ( "testFail_assume_true" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( AssumeTest . test_assume_false ( V0_a , V1_b ) => #abiCallData ( "test_assume_false" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( AssumeTest . test_assume_staticCall ( V0_a ) => #abiCallData ( "test_assume_staticCall" , #bool ( V0_a ) , .TypedArgs ) )
       ensures #rangeBool ( V0_a )
      
    
    rule  ( AssumeTest . test_assume_true ( V0_a , V1_b ) => #abiCallData ( "test_assume_true" , #uint256 ( V0_a ) , #uint256 ( V1_b ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_a )
       andBool ( #rangeUInt ( 256 , V1_b )
               ))
      
    
    rule  ( AssumeTest . test_multi_assume ( V0_alice , V1_bob ) => #abiCallData ( "test_multi_assume" , #address ( V0_alice ) , #address ( V1_bob ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_alice )
       andBool ( #rangeAddress ( V1_bob )
               ))
      
    
    rule  ( AssumeTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testFail_assume_false" ) => 1596879099 )
      
    
    rule  ( selector ( "testFail_assume_true" ) => 246830810 )
      
    
    rule  ( selector ( "test_assume_false" ) => 3827036084 )
      
    
    rule  ( selector ( "test_assume_staticCall" ) => 1479621703 )
      
    
    rule  ( selector ( "test_assume_true" ) => 1861181564 )
      
    
    rule  ( selector ( "test_multi_assume" ) => 2625007844 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module BLOCKPARAMSTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= BlockParamsTestContract
    
    syntax BlockParamsTestContract ::= "BlockParamsTest" [symbol(), klabel(contract_BlockParamsTest)]
    
      
    
    syntax Field ::= BlockParamsTestField
    
    syntax BlockParamsTestField ::= "IS_TEST" [symbol(), klabel(field_BlockParamsTest_IS_TEST)]
    
    syntax BlockParamsTestField ::= "_failed" [symbol(), klabel(field_BlockParamsTest__failed)]
    
    syntax BlockParamsTestField ::= "IS_SCRIPT" [symbol(), klabel(field_BlockParamsTest_IS_SCRIPT)]
    
    syntax BlockParamsTestField ::= "stdstore" [symbol(), klabel(field_BlockParamsTest_stdstore)]
    
    rule  ( #loc ( BlockParamsTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( BlockParamsTest . _failed ) => 0 )
      
    
    rule  ( #loc ( BlockParamsTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( BlockParamsTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= BlockParamsTestContract "." BlockParamsTestMethod [function(), symbol(), klabel(method_BlockParamsTest)]
    
    syntax BlockParamsTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_BlockParamsTest_IS_SCRIPT)]
    
    syntax BlockParamsTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_BlockParamsTest_IS_TEST)]
    
    syntax BlockParamsTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_BlockParamsTest_failed)]
    
    syntax BlockParamsTestMethod ::= "testChainId" "(" Int ")" [symbol(), klabel(method_BlockParamsTest_testChainId)]
    
    syntax BlockParamsTestMethod ::= "testCoinBase" "(" ")" [symbol(), klabel(method_BlockParamsTest_testCoinBase)]
    
    syntax BlockParamsTestMethod ::= "testFee" "(" Int ")" [symbol(), klabel(method_BlockParamsTest_testFee)]
    
    syntax BlockParamsTestMethod ::= "testRoll" "(" Int ")" [symbol(), klabel(method_BlockParamsTest_testRoll)]
    
    syntax BlockParamsTestMethod ::= "testWarp" "(" Int ")" [symbol(), klabel(method_BlockParamsTest_testWarp)]
    
    syntax BlockParamsTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_BlockParamsTest_vm)]
    
    rule  ( BlockParamsTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( BlockParamsTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( BlockParamsTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( BlockParamsTest . testChainId ( V0_newChainId ) => #abiCallData ( "testChainId" , #uint256 ( V0_newChainId ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_newChainId )
      
    
    rule  ( BlockParamsTest . testCoinBase ( ) => #abiCallData ( "testCoinBase" , .TypedArgs ) )
      
    
    rule  ( BlockParamsTest . testFee ( V0_newFee ) => #abiCallData ( "testFee" , #uint256 ( V0_newFee ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_newFee )
      
    
    rule  ( BlockParamsTest . testRoll ( V0_newHeight ) => #abiCallData ( "testRoll" , #uint256 ( V0_newHeight ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_newHeight )
      
    
    rule  ( BlockParamsTest . testWarp ( V0_time ) => #abiCallData ( "testWarp" , #uint256 ( V0_time ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_time )
      
    
    rule  ( BlockParamsTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testChainId" ) => 486990902 )
      
    
    rule  ( selector ( "testCoinBase" ) => 2231467180 )
      
    
    rule  ( selector ( "testFee" ) => 687351365 )
      
    
    rule  ( selector ( "testRoll" ) => 3832502715 )
      
    
    rule  ( selector ( "testWarp" ) => 1957961066 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module BROADCASTTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= BroadcastTestContract
    
    syntax BroadcastTestContract ::= "BroadcastTest" [symbol(), klabel(contract_BroadcastTest)]
    
      
    
    syntax Field ::= BroadcastTestField
    
    syntax BroadcastTestField ::= "IS_TEST" [symbol(), klabel(field_BroadcastTest_IS_TEST)]
    
    syntax BroadcastTestField ::= "_failed" [symbol(), klabel(field_BroadcastTest__failed)]
    
    syntax BroadcastTestField ::= "IS_SCRIPT" [symbol(), klabel(field_BroadcastTest_IS_SCRIPT)]
    
    syntax BroadcastTestField ::= "stdstore" [symbol(), klabel(field_BroadcastTest_stdstore)]
    
    syntax BroadcastTestField ::= "ACCOUNT_A" [symbol(), klabel(field_BroadcastTest_ACCOUNT_A)]
    
    syntax BroadcastTestField ::= "ACCOUNT_B" [symbol(), klabel(field_BroadcastTest_ACCOUNT_B)]
    
    rule  ( #loc ( BroadcastTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( BroadcastTest . _failed ) => 0 )
      
    
    rule  ( #loc ( BroadcastTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( BroadcastTest . stdstore ) => 1 )
      
    
    rule  ( #loc ( BroadcastTest . ACCOUNT_A ) => 8 )
      
    
    rule  ( #loc ( BroadcastTest . ACCOUNT_B ) => 9 )
      
    
    syntax Bytes ::= BroadcastTestContract "." BroadcastTestMethod [function(), symbol(), klabel(method_BroadcastTest)]
    
    syntax BroadcastTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_BroadcastTest_IS_SCRIPT)]
    
    syntax BroadcastTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_BroadcastTest_IS_TEST)]
    
    syntax BroadcastTestMethod ::= "deployNoArgs" "(" ")" [symbol(), klabel(method_BroadcastTest_deployNoArgs)]
    
    syntax BroadcastTestMethod ::= "deployOther" "(" ")" [symbol(), klabel(method_BroadcastTest_deployOther)]
    
    syntax BroadcastTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_BroadcastTest_failed)]
    
    syntax BroadcastTestMethod ::= "setUp" "(" ")" [symbol(), klabel(method_BroadcastTest_setUp)]
    
    syntax BroadcastTestMethod ::= "testDeploy" "(" ")" [symbol(), klabel(method_BroadcastTest_testDeploy)]
    
    syntax BroadcastTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_BroadcastTest_vm)]
    
    rule  ( BroadcastTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( BroadcastTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( BroadcastTest . deployNoArgs ( ) => #abiCallData ( "deployNoArgs" , .TypedArgs ) )
      
    
    rule  ( BroadcastTest . deployOther ( ) => #abiCallData ( "deployOther" , .TypedArgs ) )
      
    
    rule  ( BroadcastTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( BroadcastTest . setUp ( ) => #abiCallData ( "setUp" , .TypedArgs ) )
      
    
    rule  ( BroadcastTest . testDeploy ( ) => #abiCallData ( "testDeploy" , .TypedArgs ) )
      
    
    rule  ( BroadcastTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "deployNoArgs" ) => 1902058844 )
      
    
    rule  ( selector ( "deployOther" ) => 4254441026 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "setUp" ) => 177362148 )
      
    
    rule  ( selector ( "testDeploy" ) => 894117685 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module CONSTANTS-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ConstantsContract
    
    syntax ConstantsContract ::= "Constants" [symbol(), klabel(contract_Constants)]
    
      

endmodule

module CONTRACT-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ContractContract
    
    syntax ContractContract ::= "Contract" [symbol(), klabel(contract_Contract)]
    
      

endmodule

module CONTRACTTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ContractTestContract
    
    syntax ContractTestContract ::= "ContractTest" [symbol(), klabel(contract_ContractTest)]
    
      
    
    syntax Field ::= ContractTestField
    
    syntax ContractTestField ::= "IS_TEST" [symbol(), klabel(field_ContractTest_IS_TEST)]
    
    syntax ContractTestField ::= "_failed" [symbol(), klabel(field_ContractTest__failed)]
    
    syntax ContractTestField ::= "IS_SCRIPT" [symbol(), klabel(field_ContractTest_IS_SCRIPT)]
    
    syntax ContractTestField ::= "stdstore" [symbol(), klabel(field_ContractTest_stdstore)]
    
    rule  ( #loc ( ContractTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( ContractTest . _failed ) => 0 )
      
    
    rule  ( #loc ( ContractTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( ContractTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= ContractTestContract "." ContractTestMethod [function(), symbol(), klabel(method_ContractTest)]
    
    syntax ContractTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_ContractTest_IS_SCRIPT)]
    
    syntax ContractTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_ContractTest_IS_TEST)]
    
    syntax ContractTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_ContractTest_failed)]
    
    syntax ContractTestMethod ::= "testExample" "(" ")" [symbol(), klabel(method_ContractTest_testExample)]
    
    syntax ContractTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_ContractTest_vm)]
    
    rule  ( ContractTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( ContractTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( ContractTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( ContractTest . testExample ( ) => #abiCallData ( "testExample" , .TypedArgs ) )
      
    
    rule  ( ContractTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testExample" ) => 1062881834 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module CONTRACTBTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ContractBTestContract
    
    syntax ContractBTestContract ::= "ContractBTest" [symbol(), klabel(contract_ContractBTest)]
    
      
    
    syntax Field ::= ContractBTestField
    
    syntax ContractBTestField ::= "IS_TEST" [symbol(), klabel(field_ContractBTest_IS_TEST)]
    
    syntax ContractBTestField ::= "_failed" [symbol(), klabel(field_ContractBTest__failed)]
    
    syntax ContractBTestField ::= "IS_SCRIPT" [symbol(), klabel(field_ContractBTest_IS_SCRIPT)]
    
    syntax ContractBTestField ::= "stdstore" [symbol(), klabel(field_ContractBTest_stdstore)]
    
    syntax ContractBTestField ::= "testNumber" [symbol(), klabel(field_ContractBTest_testNumber)]
    
    rule  ( #loc ( ContractBTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( ContractBTest . _failed ) => 0 )
      
    
    rule  ( #loc ( ContractBTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( ContractBTest . stdstore ) => 1 )
      
    
    rule  ( #loc ( ContractBTest . testNumber ) => 8 )
      
    
    syntax Bytes ::= ContractBTestContract "." ContractBTestMethod [function(), symbol(), klabel(method_ContractBTest)]
    
    syntax ContractBTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_ContractBTest_IS_SCRIPT)]
    
    syntax ContractBTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_ContractBTest_IS_TEST)]
    
    syntax ContractBTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_ContractBTest_failed)]
    
    syntax ContractBTestMethod ::= "setUp" "(" ")" [symbol(), klabel(method_ContractBTest_setUp)]
    
    syntax ContractBTestMethod ::= "testCannotSubtract43" "(" ")" [symbol(), klabel(method_ContractBTest_testCannotSubtract43)]
    
    syntax ContractBTestMethod ::= "testFailSubtract43" "(" ")" [symbol(), klabel(method_ContractBTest_testFailSubtract43)]
    
    syntax ContractBTestMethod ::= "testNumberIs42" "(" ")" [symbol(), klabel(method_ContractBTest_testNumberIs42)]
    
    syntax ContractBTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_ContractBTest_vm)]
    
    rule  ( ContractBTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( ContractBTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( ContractBTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( ContractBTest . setUp ( ) => #abiCallData ( "setUp" , .TypedArgs ) )
      
    
    rule  ( ContractBTest . testCannotSubtract43 ( ) => #abiCallData ( "testCannotSubtract43" , .TypedArgs ) )
      
    
    rule  ( ContractBTest . testFailSubtract43 ( ) => #abiCallData ( "testFailSubtract43" , .TypedArgs ) )
      
    
    rule  ( ContractBTest . testNumberIs42 ( ) => #abiCallData ( "testNumberIs42" , .TypedArgs ) )
      
    
    rule  ( ContractBTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "setUp" ) => 177362148 )
      
    
    rule  ( selector ( "testCannotSubtract43" ) => 932201548 )
      
    
    rule  ( selector ( "testFailSubtract43" ) => 1021814620 )
      
    
    rule  ( selector ( "testNumberIs42" ) => 795542700 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module COUNTER-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= CounterContract
    
    syntax CounterContract ::= "Counter" [symbol(), klabel(contract_Counter)]
    
      
    
    syntax Field ::= CounterField
    
    syntax CounterField ::= "number" [symbol(), klabel(field_Counter_number)]
    
    rule  ( #loc ( Counter . number ) => 0 )
      
    
    syntax Bytes ::= CounterContract "." CounterMethod [function(), symbol(), klabel(method_Counter)]
    
    syntax CounterMethod ::= "increment" "(" ")" [symbol(), klabel(method_Counter_increment)]
    
    syntax CounterMethod ::= "number" "(" ")" [symbol(), klabel(method_Counter_number)]
    
    syntax CounterMethod ::= "setNumber" "(" Int ")" [symbol(), klabel(method_Counter_setNumber)]
    
    rule  ( Counter . increment ( ) => #abiCallData ( "increment" , .TypedArgs ) )
      
    
    rule  ( Counter . number ( ) => #abiCallData ( "number" , .TypedArgs ) )
      
    
    rule  ( Counter . setNumber ( V0_newNumber ) => #abiCallData ( "setNumber" , #uint256 ( V0_newNumber ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_newNumber )
      
    
    rule  ( selector ( "increment" ) => 3500007562 )
      
    
    rule  ( selector ( "number" ) => 2206332298 )
      
    
    rule  ( selector ( "setNumber" ) => 1068876235 )
      

endmodule

module COUNTERTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= CounterTestContract
    
    syntax CounterTestContract ::= "CounterTest" [symbol(), klabel(contract_CounterTest)]
    
      
    
    syntax Field ::= CounterTestField
    
    syntax CounterTestField ::= "IS_TEST" [symbol(), klabel(field_CounterTest_IS_TEST)]
    
    syntax CounterTestField ::= "_failed" [symbol(), klabel(field_CounterTest__failed)]
    
    syntax CounterTestField ::= "IS_SCRIPT" [symbol(), klabel(field_CounterTest_IS_SCRIPT)]
    
    syntax CounterTestField ::= "stdstore" [symbol(), klabel(field_CounterTest_stdstore)]
    
    syntax CounterTestField ::= "counter" [symbol(), klabel(field_CounterTest_counter)]
    
    rule  ( #loc ( CounterTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( CounterTest . _failed ) => 0 )
      
    
    rule  ( #loc ( CounterTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( CounterTest . stdstore ) => 1 )
      
    
    rule  ( #loc ( CounterTest . counter ) => 8 )
      
    
    syntax Bytes ::= CounterTestContract "." CounterTestMethod [function(), symbol(), klabel(method_CounterTest)]
    
    syntax CounterTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_CounterTest_IS_SCRIPT)]
    
    syntax CounterTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_CounterTest_IS_TEST)]
    
    syntax CounterTestMethod ::= "counter" "(" ")" [symbol(), klabel(method_CounterTest_counter)]
    
    syntax CounterTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_CounterTest_failed)]
    
    syntax CounterTestMethod ::= "kevm" "(" ")" [symbol(), klabel(method_CounterTest_kevm)]
    
    syntax CounterTestMethod ::= "testIncrement" "(" ")" [symbol(), klabel(method_CounterTest_testIncrement)]
    
    syntax CounterTestMethod ::= "testSetNumber" "(" Int ")" [symbol(), klabel(method_CounterTest_testSetNumber)]
    
    syntax CounterTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_CounterTest_vm)]
    
    rule  ( CounterTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( CounterTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( CounterTest . counter ( ) => #abiCallData ( "counter" , .TypedArgs ) )
      
    
    rule  ( CounterTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( CounterTest . kevm ( ) => #abiCallData ( "kevm" , .TypedArgs ) )
      
    
    rule  ( CounterTest . testIncrement ( ) => #abiCallData ( "testIncrement" , .TypedArgs ) )
      
    
    rule  ( CounterTest . testSetNumber ( V0_x ) => #abiCallData ( "testSetNumber" , #uint256 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( CounterTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "counter" ) => 1639719450 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "kevm" ) => 3601001590 )
      
    
    rule  ( selector ( "testIncrement" ) => 3105072586 )
      
    
    rule  ( selector ( "testSetNumber" ) => 1895400894 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module DYNAMICTYPES-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= DynamicTypesContract
    
    syntax DynamicTypesContract ::= "DynamicTypes" [symbol(), klabel(contract_DynamicTypes)]
    
      
    
    syntax Field ::= DynamicTypesField
    
    syntax DynamicTypesField ::= "IS_TEST" [symbol(), klabel(field_DynamicTypes_IS_TEST)]
    
    syntax DynamicTypesField ::= "_failed" [symbol(), klabel(field_DynamicTypes__failed)]
    
    syntax DynamicTypesField ::= "IS_SCRIPT" [symbol(), klabel(field_DynamicTypes_IS_SCRIPT)]
    
    syntax DynamicTypesField ::= "stdstore" [symbol(), klabel(field_DynamicTypes_stdstore)]
    
    rule  ( #loc ( DynamicTypes . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( DynamicTypes . _failed ) => 0 )
      
    
    rule  ( #loc ( DynamicTypes . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( DynamicTypes . stdstore ) => 1 )
      
    
    syntax Bytes ::= DynamicTypesContract "." DynamicTypesMethod [function(), symbol(), klabel(method_DynamicTypes)]
    
    syntax DynamicTypesMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_DynamicTypes_IS_SCRIPT)]
    
    syntax DynamicTypesMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_DynamicTypes_IS_TEST)]
    
    syntax DynamicTypesMethod ::= "failed" "(" ")" [symbol(), klabel(method_DynamicTypes_failed)]
    
    syntax DynamicTypesMethod ::= "test_dynamic_byte_read" "(" Bytes "," Int ")" [symbol(), klabel(method_DynamicTypes_test_dynamic_byte_read)]
    
    syntax DynamicTypesMethod ::= "vm" "(" ")" [symbol(), klabel(method_DynamicTypes_vm)]
    
    rule  ( DynamicTypes . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( DynamicTypes . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( DynamicTypes . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( DynamicTypes . test_dynamic_byte_read ( V0_data , V1_offset ) => #abiCallData ( "test_dynamic_byte_read" , #bytes ( V0_data ) , #uint256 ( V1_offset ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 128 , lengthBytes ( V0_data ) )
       andBool ( #rangeUInt ( 256 , V1_offset )
               ))
      
    
    rule  ( DynamicTypes . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "test_dynamic_byte_read" ) => 4003228173 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module EXPECTEMIT-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ExpectEmitContract
    
    syntax ExpectEmitContract ::= "ExpectEmit" [symbol(), klabel(contract_ExpectEmit)]
    
      
    
    syntax Bytes ::= ExpectEmitContract "." ExpectEmitMethod [function(), symbol(), klabel(method_ExpectEmit)]
    
    syntax ExpectEmitMethod ::= "t" "(" ")" [symbol(), klabel(method_ExpectEmit_t)]
    
    rule  ( ExpectEmit . t ( ) => #abiCallData ( "t" , .TypedArgs ) )
      
    
    rule  ( selector ( "t" ) => 2463158611 )
      

endmodule

module EMITCONTRACTTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= EmitContractTestContract
    
    syntax EmitContractTestContract ::= "EmitContractTest" [symbol(), klabel(contract_EmitContractTest)]
    
      
    
    syntax Field ::= EmitContractTestField
    
    syntax EmitContractTestField ::= "IS_TEST" [symbol(), klabel(field_EmitContractTest_IS_TEST)]
    
    syntax EmitContractTestField ::= "_failed" [symbol(), klabel(field_EmitContractTest__failed)]
    
    syntax EmitContractTestField ::= "IS_SCRIPT" [symbol(), klabel(field_EmitContractTest_IS_SCRIPT)]
    
    syntax EmitContractTestField ::= "stdstore" [symbol(), klabel(field_EmitContractTest_stdstore)]
    
    rule  ( #loc ( EmitContractTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( EmitContractTest . _failed ) => 0 )
      
    
    rule  ( #loc ( EmitContractTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( EmitContractTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= EmitContractTestContract "." EmitContractTestMethod [function(), symbol(), klabel(method_EmitContractTest)]
    
    syntax EmitContractTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_EmitContractTest_IS_SCRIPT)]
    
    syntax EmitContractTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_EmitContractTest_IS_TEST)]
    
    syntax EmitContractTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_EmitContractTest_failed)]
    
    syntax EmitContractTestMethod ::= "testExpectEmit" "(" ")" [symbol(), klabel(method_EmitContractTest_testExpectEmit)]
    
    syntax EmitContractTestMethod ::= "testExpectEmitCheckEmitter" "(" ")" [symbol(), klabel(method_EmitContractTest_testExpectEmitCheckEmitter)]
    
    syntax EmitContractTestMethod ::= "testExpectEmitDoNotCheckData" "(" ")" [symbol(), klabel(method_EmitContractTest_testExpectEmitDoNotCheckData)]
    
    syntax EmitContractTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_EmitContractTest_vm)]
    
    rule  ( EmitContractTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( EmitContractTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( EmitContractTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( EmitContractTest . testExpectEmit ( ) => #abiCallData ( "testExpectEmit" , .TypedArgs ) )
      
    
    rule  ( EmitContractTest . testExpectEmitCheckEmitter ( ) => #abiCallData ( "testExpectEmitCheckEmitter" , .TypedArgs ) )
      
    
    rule  ( EmitContractTest . testExpectEmitDoNotCheckData ( ) => #abiCallData ( "testExpectEmitDoNotCheckData" , .TypedArgs ) )
      
    
    rule  ( EmitContractTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testExpectEmit" ) => 2385562937 )
      
    
    rule  ( selector ( "testExpectEmitCheckEmitter" ) => 3822672185 )
      
    
    rule  ( selector ( "testExpectEmitDoNotCheckData" ) => 4244930061 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module ENVTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= EnvTestContract
    
    syntax EnvTestContract ::= "EnvTest" [symbol(), klabel(contract_EnvTest)]
    
      
    
    syntax Field ::= EnvTestField
    
    syntax EnvTestField ::= "IS_TEST" [symbol(), klabel(field_EnvTest_IS_TEST)]
    
    syntax EnvTestField ::= "_failed" [symbol(), klabel(field_EnvTest__failed)]
    
    syntax EnvTestField ::= "IS_SCRIPT" [symbol(), klabel(field_EnvTest_IS_SCRIPT)]
    
    syntax EnvTestField ::= "stdstore" [symbol(), klabel(field_EnvTest_stdstore)]
    
    rule  ( #loc ( EnvTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( EnvTest . _failed ) => 0 )
      
    
    rule  ( #loc ( EnvTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( EnvTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= EnvTestContract "." EnvTestMethod [function(), symbol(), klabel(method_EnvTest)]
    
    syntax EnvTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_EnvTest_IS_SCRIPT)]
    
    syntax EnvTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_EnvTest_IS_TEST)]
    
    syntax EnvTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_EnvTest_failed)]
    
    syntax EnvTestMethod ::= "testEnvAddress" "(" ")" [symbol(), klabel(method_EnvTest_testEnvAddress)]
    
    syntax EnvTestMethod ::= "testEnvAddresseArray" "(" ")" [symbol(), klabel(method_EnvTest_testEnvAddresseArray)]
    
    syntax EnvTestMethod ::= "testEnvBool" "(" ")" [symbol(), klabel(method_EnvTest_testEnvBool)]
    
    syntax EnvTestMethod ::= "testEnvBoolArray" "(" ")" [symbol(), klabel(method_EnvTest_testEnvBoolArray)]
    
    syntax EnvTestMethod ::= "testEnvBytes" "(" ")" [symbol(), klabel(method_EnvTest_testEnvBytes)]
    
    syntax EnvTestMethod ::= "testEnvBytes32" "(" ")" [symbol(), klabel(method_EnvTest_testEnvBytes32)]
    
    syntax EnvTestMethod ::= "testEnvBytes32Array" "(" ")" [symbol(), klabel(method_EnvTest_testEnvBytes32Array)]
    
    syntax EnvTestMethod ::= "testEnvBytesArray" "(" ")" [symbol(), klabel(method_EnvTest_testEnvBytesArray)]
    
    syntax EnvTestMethod ::= "testEnvInt" "(" ")" [symbol(), klabel(method_EnvTest_testEnvInt)]
    
    syntax EnvTestMethod ::= "testEnvIntArray" "(" ")" [symbol(), klabel(method_EnvTest_testEnvIntArray)]
    
    syntax EnvTestMethod ::= "testEnvString" "(" ")" [symbol(), klabel(method_EnvTest_testEnvString)]
    
    syntax EnvTestMethod ::= "testEnvStringArray" "(" ")" [symbol(), klabel(method_EnvTest_testEnvStringArray)]
    
    syntax EnvTestMethod ::= "testEnvUInt" "(" ")" [symbol(), klabel(method_EnvTest_testEnvUInt)]
    
    syntax EnvTestMethod ::= "testEnvUIntArray" "(" ")" [symbol(), klabel(method_EnvTest_testEnvUIntArray)]
    
    syntax EnvTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_EnvTest_vm)]
    
    rule  ( EnvTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( EnvTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( EnvTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvAddress ( ) => #abiCallData ( "testEnvAddress" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvAddresseArray ( ) => #abiCallData ( "testEnvAddresseArray" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvBool ( ) => #abiCallData ( "testEnvBool" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvBoolArray ( ) => #abiCallData ( "testEnvBoolArray" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvBytes ( ) => #abiCallData ( "testEnvBytes" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvBytes32 ( ) => #abiCallData ( "testEnvBytes32" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvBytes32Array ( ) => #abiCallData ( "testEnvBytes32Array" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvBytesArray ( ) => #abiCallData ( "testEnvBytesArray" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvInt ( ) => #abiCallData ( "testEnvInt" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvIntArray ( ) => #abiCallData ( "testEnvIntArray" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvString ( ) => #abiCallData ( "testEnvString" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvStringArray ( ) => #abiCallData ( "testEnvStringArray" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvUInt ( ) => #abiCallData ( "testEnvUInt" , .TypedArgs ) )
      
    
    rule  ( EnvTest . testEnvUIntArray ( ) => #abiCallData ( "testEnvUIntArray" , .TypedArgs ) )
      
    
    rule  ( EnvTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testEnvAddress" ) => 2862857531 )
      
    
    rule  ( selector ( "testEnvAddresseArray" ) => 3294476741 )
      
    
    rule  ( selector ( "testEnvBool" ) => 894343624 )
      
    
    rule  ( selector ( "testEnvBoolArray" ) => 2095834153 )
      
    
    rule  ( selector ( "testEnvBytes" ) => 1439135834 )
      
    
    rule  ( selector ( "testEnvBytes32" ) => 1818390676 )
      
    
    rule  ( selector ( "testEnvBytes32Array" ) => 1427447379 )
      
    
    rule  ( selector ( "testEnvBytesArray" ) => 2593538909 )
      
    
    rule  ( selector ( "testEnvInt" ) => 446472630 )
      
    
    rule  ( selector ( "testEnvIntArray" ) => 994678527 )
      
    
    rule  ( selector ( "testEnvString" ) => 1097637738 )
      
    
    rule  ( selector ( "testEnvStringArray" ) => 3587215751 )
      
    
    rule  ( selector ( "testEnvUInt" ) => 2066287170 )
      
    
    rule  ( selector ( "testEnvUIntArray" ) => 551796351 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module DUMMY-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= DummyContract
    
    syntax DummyContract ::= "Dummy" [symbol(), klabel(contract_Dummy)]
    
      
    
    syntax Bytes ::= DummyContract "." DummyMethod [function(), symbol(), klabel(method_Dummy)]
    
    syntax DummyMethod ::= "numberA" "(" ")" [symbol(), klabel(method_Dummy_numberA)]
    
    rule  ( Dummy . numberA ( ) => #abiCallData ( "numberA" , .TypedArgs ) )
      
    
    rule  ( selector ( "numberA" ) => 2571869527 )
      

endmodule

module EXPECTCALLTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ExpectCallTestContract
    
    syntax ExpectCallTestContract ::= "ExpectCallTest" [symbol(), klabel(contract_ExpectCallTest)]
    
      
    
    syntax Field ::= ExpectCallTestField
    
    syntax ExpectCallTestField ::= "IS_TEST" [symbol(), klabel(field_ExpectCallTest_IS_TEST)]
    
    syntax ExpectCallTestField ::= "_failed" [symbol(), klabel(field_ExpectCallTest__failed)]
    
    syntax ExpectCallTestField ::= "IS_SCRIPT" [symbol(), klabel(field_ExpectCallTest_IS_SCRIPT)]
    
    syntax ExpectCallTestField ::= "stdstore" [symbol(), klabel(field_ExpectCallTest_stdstore)]
    
    rule  ( #loc ( ExpectCallTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( ExpectCallTest . _failed ) => 0 )
      
    
    rule  ( #loc ( ExpectCallTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( ExpectCallTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= ExpectCallTestContract "." ExpectCallTestMethod [function(), symbol(), klabel(method_ExpectCallTest)]
    
    syntax ExpectCallTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_ExpectCallTest_IS_SCRIPT)]
    
    syntax ExpectCallTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_ExpectCallTest_IS_TEST)]
    
    syntax ExpectCallTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_ExpectCallTest_failed)]
    
    syntax ExpectCallTestMethod ::= "kevm" "(" ")" [symbol(), klabel(method_ExpectCallTest_kevm)]
    
    syntax ExpectCallTestMethod ::= "testExpectRegularCall" "(" ")" [symbol(), klabel(method_ExpectCallTest_testExpectRegularCall)]
    
    syntax ExpectCallTestMethod ::= "testExpectStaticCall" "(" ")" [symbol(), klabel(method_ExpectCallTest_testExpectStaticCall)]
    
    syntax ExpectCallTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_ExpectCallTest_vm)]
    
    rule  ( ExpectCallTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( ExpectCallTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( ExpectCallTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( ExpectCallTest . kevm ( ) => #abiCallData ( "kevm" , .TypedArgs ) )
      
    
    rule  ( ExpectCallTest . testExpectRegularCall ( ) => #abiCallData ( "testExpectRegularCall" , .TypedArgs ) )
      
    
    rule  ( ExpectCallTest . testExpectStaticCall ( ) => #abiCallData ( "testExpectStaticCall" , .TypedArgs ) )
      
    
    rule  ( ExpectCallTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "kevm" ) => 3601001590 )
      
    
    rule  ( selector ( "testExpectRegularCall" ) => 676731872 )
      
    
    rule  ( selector ( "testExpectStaticCall" ) => 3219733999 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module DEPTHREVERTER-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= DepthReverterContract
    
    syntax DepthReverterContract ::= "DepthReverter" [symbol(), klabel(contract_DepthReverter)]
    
      
    
    syntax Field ::= DepthReverterField
    
    syntax DepthReverterField ::= "reverter" [symbol(), klabel(field_DepthReverter_reverter)]
    
    rule  ( #loc ( DepthReverter . reverter ) => 0 )
      
    
    syntax Bytes ::= DepthReverterContract "." DepthReverterMethod [function(), symbol(), klabel(method_DepthReverter)]
    
    syntax DepthReverterMethod ::= "revertAtNextDepth" "(" ")" [symbol(), klabel(method_DepthReverter_revertAtNextDepth)]
    
    rule  ( DepthReverter . revertAtNextDepth ( ) => #abiCallData ( "revertAtNextDepth" , .TypedArgs ) )
      
    
    rule  ( selector ( "revertAtNextDepth" ) => 332278727 )
      

endmodule

module EXPECTREVERTTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ExpectRevertTestContract
    
    syntax ExpectRevertTestContract ::= "ExpectRevertTest" [symbol(), klabel(contract_ExpectRevertTest)]
    
      
    
    syntax Field ::= ExpectRevertTestField
    
    syntax ExpectRevertTestField ::= "IS_TEST" [symbol(), klabel(field_ExpectRevertTest_IS_TEST)]
    
    syntax ExpectRevertTestField ::= "_failed" [symbol(), klabel(field_ExpectRevertTest__failed)]
    
    syntax ExpectRevertTestField ::= "IS_SCRIPT" [symbol(), klabel(field_ExpectRevertTest_IS_SCRIPT)]
    
    syntax ExpectRevertTestField ::= "stdstore" [symbol(), klabel(field_ExpectRevertTest_stdstore)]
    
    rule  ( #loc ( ExpectRevertTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( ExpectRevertTest . _failed ) => 0 )
      
    
    rule  ( #loc ( ExpectRevertTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( ExpectRevertTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= ExpectRevertTestContract "." ExpectRevertTestMethod [function(), symbol(), klabel(method_ExpectRevertTest)]
    
    syntax ExpectRevertTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_ExpectRevertTest_IS_SCRIPT)]
    
    syntax ExpectRevertTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_ExpectRevertTest_IS_TEST)]
    
    syntax ExpectRevertTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_ExpectRevertTest_failed)]
    
    syntax ExpectRevertTestMethod ::= "testFail_ExpectRevert_failAndSuccess" "(" ")" [symbol(), klabel(method_ExpectRevertTest_testFail_ExpectRevert_failAndSuccess)]
    
    syntax ExpectRevertTestMethod ::= "testFail_expectRevert_bytes4" "(" ")" [symbol(), klabel(method_ExpectRevertTest_testFail_expectRevert_bytes4)]
    
    syntax ExpectRevertTestMethod ::= "testFail_expectRevert_empty" "(" ")" [symbol(), klabel(method_ExpectRevertTest_testFail_expectRevert_empty)]
    
    syntax ExpectRevertTestMethod ::= "testFail_expectRevert_false" "(" ")" [symbol(), klabel(method_ExpectRevertTest_testFail_expectRevert_false)]
    
    syntax ExpectRevertTestMethod ::= "testFail_expectRevert_multipleReverts" "(" ")" [symbol(), klabel(method_ExpectRevertTest_testFail_expectRevert_multipleReverts)]
    
    syntax ExpectRevertTestMethod ::= "test_ExpectRevert_increasedDepth" "(" ")" [symbol(), klabel(method_ExpectRevertTest_test_ExpectRevert_increasedDepth)]
    
    syntax ExpectRevertTestMethod ::= "test_expectRevert_bytes4" "(" ")" [symbol(), klabel(method_ExpectRevertTest_test_expectRevert_bytes4)]
    
    syntax ExpectRevertTestMethod ::= "test_expectRevert_encodedSymbolic" "(" Int ")" [symbol(), klabel(method_ExpectRevertTest_test_expectRevert_encodedSymbolic)]
    
    syntax ExpectRevertTestMethod ::= "test_expectRevert_internalCall" "(" ")" [symbol(), klabel(method_ExpectRevertTest_test_expectRevert_internalCall)]
    
    syntax ExpectRevertTestMethod ::= "test_expectRevert_message" "(" ")" [symbol(), klabel(method_ExpectRevertTest_test_expectRevert_message)]
    
    syntax ExpectRevertTestMethod ::= "test_expectRevert_returnValue" "(" ")" [symbol(), klabel(method_ExpectRevertTest_test_expectRevert_returnValue)]
    
    syntax ExpectRevertTestMethod ::= "test_expectRevert_true" "(" ")" [symbol(), klabel(method_ExpectRevertTest_test_expectRevert_true)]
    
    syntax ExpectRevertTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_ExpectRevertTest_vm)]
    
    rule  ( ExpectRevertTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . testFail_ExpectRevert_failAndSuccess ( ) => #abiCallData ( "testFail_ExpectRevert_failAndSuccess" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . testFail_expectRevert_bytes4 ( ) => #abiCallData ( "testFail_expectRevert_bytes4" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . testFail_expectRevert_empty ( ) => #abiCallData ( "testFail_expectRevert_empty" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . testFail_expectRevert_false ( ) => #abiCallData ( "testFail_expectRevert_false" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . testFail_expectRevert_multipleReverts ( ) => #abiCallData ( "testFail_expectRevert_multipleReverts" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . test_ExpectRevert_increasedDepth ( ) => #abiCallData ( "test_ExpectRevert_increasedDepth" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . test_expectRevert_bytes4 ( ) => #abiCallData ( "test_expectRevert_bytes4" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . test_expectRevert_encodedSymbolic ( V0_controller ) => #abiCallData ( "test_expectRevert_encodedSymbolic" , #address ( V0_controller ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_controller )
      
    
    rule  ( ExpectRevertTest . test_expectRevert_internalCall ( ) => #abiCallData ( "test_expectRevert_internalCall" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . test_expectRevert_message ( ) => #abiCallData ( "test_expectRevert_message" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . test_expectRevert_returnValue ( ) => #abiCallData ( "test_expectRevert_returnValue" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . test_expectRevert_true ( ) => #abiCallData ( "test_expectRevert_true" , .TypedArgs ) )
      
    
    rule  ( ExpectRevertTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testFail_ExpectRevert_failAndSuccess" ) => 2386222785 )
      
    
    rule  ( selector ( "testFail_expectRevert_bytes4" ) => 3540765930 )
      
    
    rule  ( selector ( "testFail_expectRevert_empty" ) => 3691097669 )
      
    
    rule  ( selector ( "testFail_expectRevert_false" ) => 2152588325 )
      
    
    rule  ( selector ( "testFail_expectRevert_multipleReverts" ) => 2539873268 )
      
    
    rule  ( selector ( "test_ExpectRevert_increasedDepth" ) => 910856553 )
      
    
    rule  ( selector ( "test_expectRevert_bytes4" ) => 1300765909 )
      
    
    rule  ( selector ( "test_expectRevert_encodedSymbolic" ) => 27292786 )
      
    
    rule  ( selector ( "test_expectRevert_internalCall" ) => 1766536967 )
      
    
    rule  ( selector ( "test_expectRevert_message" ) => 3706733127 )
      
    
    rule  ( selector ( "test_expectRevert_returnValue" ) => 4193569282 )
      
    
    rule  ( selector ( "test_expectRevert_true" ) => 2931127071 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module REVERTER-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ReverterContract
    
    syntax ReverterContract ::= "Reverter" [symbol(), klabel(contract_Reverter)]
    
      
    
    syntax Bytes ::= ReverterContract "." ReverterMethod [function(), symbol(), klabel(method_Reverter)]
    
    syntax ReverterMethod ::= "noRevert" "(" ")" [symbol(), klabel(method_Reverter_noRevert)]
    
    syntax ReverterMethod ::= "revertWithReason" "(" String ")" [symbol(), klabel(method_Reverter_revertWithReason)]
    
    syntax ReverterMethod ::= "revertWithoutReason" "(" ")" [symbol(), klabel(method_Reverter_revertWithoutReason)]
    
    rule  ( Reverter . noRevert ( ) => #abiCallData ( "noRevert" , .TypedArgs ) )
      
    
    rule  ( Reverter . revertWithReason ( V0__a ) => #abiCallData ( "revertWithReason" , #string ( V0__a ) , .TypedArgs ) )
      
    
    rule  ( Reverter . revertWithoutReason ( ) => #abiCallData ( "revertWithoutReason" , .TypedArgs ) )
      
    
    rule  ( selector ( "noRevert" ) => 3072618433 )
      
    
    rule  ( selector ( "revertWithReason" ) => 4154655617 )
      
    
    rule  ( selector ( "revertWithoutReason" ) => 1097275021 )
      

endmodule

module REVERTERWITHRETURN-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ReverterWithReturnContract
    
    syntax ReverterWithReturnContract ::= "ReverterWithReturn" [symbol(), klabel(contract_ReverterWithReturn)]
    
      
    
    syntax Bytes ::= ReverterWithReturnContract "." ReverterWithReturnMethod [function(), symbol(), klabel(method_ReverterWithReturn)]
    
    syntax ReverterWithReturnMethod ::= "revertUnless" "(" Int ")" [symbol(), klabel(method_ReverterWithReturn_revertUnless)]
    
    rule  ( ReverterWithReturn . revertUnless ( V0_returnInstead ) => #abiCallData ( "revertUnless" , #bool ( V0_returnInstead ) , .TypedArgs ) )
       ensures #rangeBool ( V0_returnInstead )
      
    
    rule  ( selector ( "revertUnless" ) => 260261997 )
      

endmodule

module FFITEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= FfiTestContract
    
    syntax FfiTestContract ::= "FfiTest" [symbol(), klabel(contract_FfiTest)]
    
      
    
    syntax Field ::= FfiTestField
    
    syntax FfiTestField ::= "IS_TEST" [symbol(), klabel(field_FfiTest_IS_TEST)]
    
    syntax FfiTestField ::= "_failed" [symbol(), klabel(field_FfiTest__failed)]
    
    syntax FfiTestField ::= "IS_SCRIPT" [symbol(), klabel(field_FfiTest_IS_SCRIPT)]
    
    syntax FfiTestField ::= "stdstore" [symbol(), klabel(field_FfiTest_stdstore)]
    
    rule  ( #loc ( FfiTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( FfiTest . _failed ) => 0 )
      
    
    rule  ( #loc ( FfiTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( FfiTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= FfiTestContract "." FfiTestMethod [function(), symbol(), klabel(method_FfiTest)]
    
    syntax FfiTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_FfiTest_IS_SCRIPT)]
    
    syntax FfiTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_FfiTest_IS_TEST)]
    
    syntax FfiTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_FfiTest_failed)]
    
    syntax FfiTestMethod ::= "setUp" "(" ")" [symbol(), klabel(method_FfiTest_setUp)]
    
    syntax FfiTestMethod ::= "testFFIFOO" "(" ")" [symbol(), klabel(method_FfiTest_testFFIFOO)]
    
    syntax FfiTestMethod ::= "testFFIScript" "(" ")" [symbol(), klabel(method_FfiTest_testFFIScript)]
    
    syntax FfiTestMethod ::= "testFFIScript2" "(" ")" [symbol(), klabel(method_FfiTest_testFFIScript2)]
    
    syntax FfiTestMethod ::= "testffi" "(" ")" [symbol(), klabel(method_FfiTest_testffi)]
    
    syntax FfiTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_FfiTest_vm)]
    
    rule  ( FfiTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( FfiTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( FfiTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( FfiTest . setUp ( ) => #abiCallData ( "setUp" , .TypedArgs ) )
      
    
    rule  ( FfiTest . testFFIFOO ( ) => #abiCallData ( "testFFIFOO" , .TypedArgs ) )
      
    
    rule  ( FfiTest . testFFIScript ( ) => #abiCallData ( "testFFIScript" , .TypedArgs ) )
      
    
    rule  ( FfiTest . testFFIScript2 ( ) => #abiCallData ( "testFFIScript2" , .TypedArgs ) )
      
    
    rule  ( FfiTest . testffi ( ) => #abiCallData ( "testffi" , .TypedArgs ) )
      
    
    rule  ( FfiTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "setUp" ) => 177362148 )
      
    
    rule  ( selector ( "testFFIFOO" ) => 2415994822 )
      
    
    rule  ( selector ( "testFFIScript" ) => 2734086837 )
      
    
    rule  ( selector ( "testFFIScript2" ) => 4125794598 )
      
    
    rule  ( selector ( "testffi" ) => 4068116 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module FILESTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= FilesTestContract
    
    syntax FilesTestContract ::= "FilesTest" [symbol(), klabel(contract_FilesTest)]
    
      
    
    syntax Field ::= FilesTestField
    
    syntax FilesTestField ::= "IS_TEST" [symbol(), klabel(field_FilesTest_IS_TEST)]
    
    syntax FilesTestField ::= "_failed" [symbol(), klabel(field_FilesTest__failed)]
    
    syntax FilesTestField ::= "IS_SCRIPT" [symbol(), klabel(field_FilesTest_IS_SCRIPT)]
    
    syntax FilesTestField ::= "stdstore" [symbol(), klabel(field_FilesTest_stdstore)]
    
    rule  ( #loc ( FilesTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( FilesTest . _failed ) => 0 )
      
    
    rule  ( #loc ( FilesTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( FilesTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= FilesTestContract "." FilesTestMethod [function(), symbol(), klabel(method_FilesTest)]
    
    syntax FilesTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_FilesTest_IS_SCRIPT)]
    
    syntax FilesTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_FilesTest_IS_TEST)]
    
    syntax FilesTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_FilesTest_failed)]
    
    syntax FilesTestMethod ::= "testFailRemoveFile" "(" ")" [symbol(), klabel(method_FilesTest_testFailRemoveFile)]
    
    syntax FilesTestMethod ::= "testReadWriteFile" "(" ")" [symbol(), klabel(method_FilesTest_testReadWriteFile)]
    
    syntax FilesTestMethod ::= "testReadWriteLine" "(" ")" [symbol(), klabel(method_FilesTest_testReadWriteLine)]
    
    syntax FilesTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_FilesTest_vm)]
    
    rule  ( FilesTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( FilesTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( FilesTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( FilesTest . testFailRemoveFile ( ) => #abiCallData ( "testFailRemoveFile" , .TypedArgs ) )
      
    
    rule  ( FilesTest . testReadWriteFile ( ) => #abiCallData ( "testReadWriteFile" , .TypedArgs ) )
      
    
    rule  ( FilesTest . testReadWriteLine ( ) => #abiCallData ( "testReadWriteLine" , .TypedArgs ) )
      
    
    rule  ( FilesTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testFailRemoveFile" ) => 2780725830 )
      
    
    rule  ( selector ( "testReadWriteFile" ) => 3880869465 )
      
    
    rule  ( selector ( "testReadWriteLine" ) => 3039298541 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module FORKTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ForkTestContract
    
    syntax ForkTestContract ::= "ForkTest" [symbol(), klabel(contract_ForkTest)]
    
      
    
    syntax Field ::= ForkTestField
    
    syntax ForkTestField ::= "IS_TEST" [symbol(), klabel(field_ForkTest_IS_TEST)]
    
    syntax ForkTestField ::= "_failed" [symbol(), klabel(field_ForkTest__failed)]
    
    syntax ForkTestField ::= "IS_SCRIPT" [symbol(), klabel(field_ForkTest_IS_SCRIPT)]
    
    syntax ForkTestField ::= "stdstore" [symbol(), klabel(field_ForkTest_stdstore)]
    
    rule  ( #loc ( ForkTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( ForkTest . _failed ) => 0 )
      
    
    rule  ( #loc ( ForkTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( ForkTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= ForkTestContract "." ForkTestMethod [function(), symbol(), klabel(method_ForkTest)]
    
    syntax ForkTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_ForkTest_IS_SCRIPT)]
    
    syntax ForkTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_ForkTest_IS_TEST)]
    
    syntax ForkTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_ForkTest_failed)]
    
    syntax ForkTestMethod ::= "testActiveFork" "(" ")" [symbol(), klabel(method_ForkTest_testActiveFork)]
    
    syntax ForkTestMethod ::= "testAllRPCUrl" "(" ")" [symbol(), klabel(method_ForkTest_testAllRPCUrl)]
    
    syntax ForkTestMethod ::= "testCreateFork" "(" ")" [symbol(), klabel(method_ForkTest_testCreateFork)]
    
    syntax ForkTestMethod ::= "testCreateForkBlock" "(" ")" [symbol(), klabel(method_ForkTest_testCreateForkBlock)]
    
    syntax ForkTestMethod ::= "testCreateSelectFork" "(" ")" [symbol(), klabel(method_ForkTest_testCreateSelectFork)]
    
    syntax ForkTestMethod ::= "testCreateSelectForkBlock" "(" ")" [symbol(), klabel(method_ForkTest_testCreateSelectForkBlock)]
    
    syntax ForkTestMethod ::= "testRPCUrl" "(" ")" [symbol(), klabel(method_ForkTest_testRPCUrl)]
    
    syntax ForkTestMethod ::= "testRPCUrlRevert" "(" ")" [symbol(), klabel(method_ForkTest_testRPCUrlRevert)]
    
    syntax ForkTestMethod ::= "testRollFork" "(" ")" [symbol(), klabel(method_ForkTest_testRollFork)]
    
    syntax ForkTestMethod ::= "testRollForkId" "(" ")" [symbol(), klabel(method_ForkTest_testRollForkId)]
    
    syntax ForkTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_ForkTest_vm)]
    
    rule  ( ForkTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( ForkTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( ForkTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( ForkTest . testActiveFork ( ) => #abiCallData ( "testActiveFork" , .TypedArgs ) )
      
    
    rule  ( ForkTest . testAllRPCUrl ( ) => #abiCallData ( "testAllRPCUrl" , .TypedArgs ) )
      
    
    rule  ( ForkTest . testCreateFork ( ) => #abiCallData ( "testCreateFork" , .TypedArgs ) )
      
    
    rule  ( ForkTest . testCreateForkBlock ( ) => #abiCallData ( "testCreateForkBlock" , .TypedArgs ) )
      
    
    rule  ( ForkTest . testCreateSelectFork ( ) => #abiCallData ( "testCreateSelectFork" , .TypedArgs ) )
      
    
    rule  ( ForkTest . testCreateSelectForkBlock ( ) => #abiCallData ( "testCreateSelectForkBlock" , .TypedArgs ) )
      
    
    rule  ( ForkTest . testRPCUrl ( ) => #abiCallData ( "testRPCUrl" , .TypedArgs ) )
      
    
    rule  ( ForkTest . testRPCUrlRevert ( ) => #abiCallData ( "testRPCUrlRevert" , .TypedArgs ) )
      
    
    rule  ( ForkTest . testRollFork ( ) => #abiCallData ( "testRollFork" , .TypedArgs ) )
      
    
    rule  ( ForkTest . testRollForkId ( ) => #abiCallData ( "testRollForkId" , .TypedArgs ) )
      
    
    rule  ( ForkTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testActiveFork" ) => 2981024546 )
      
    
    rule  ( selector ( "testAllRPCUrl" ) => 707490019 )
      
    
    rule  ( selector ( "testCreateFork" ) => 9848133 )
      
    
    rule  ( selector ( "testCreateForkBlock" ) => 2820856803 )
      
    
    rule  ( selector ( "testCreateSelectFork" ) => 2307095206 )
      
    
    rule  ( selector ( "testCreateSelectForkBlock" ) => 269695700 )
      
    
    rule  ( selector ( "testRPCUrl" ) => 3938449696 )
      
    
    rule  ( selector ( "testRPCUrlRevert" ) => 470834373 )
      
    
    rule  ( selector ( "testRollFork" ) => 3222356361 )
      
    
    rule  ( selector ( "testRollForkId" ) => 3215996813 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module GASTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= GasTestContract
    
    syntax GasTestContract ::= "GasTest" [symbol(), klabel(contract_GasTest)]
    
      
    
    syntax Field ::= GasTestField
    
    syntax GasTestField ::= "IS_TEST" [symbol(), klabel(field_GasTest_IS_TEST)]
    
    syntax GasTestField ::= "_failed" [symbol(), klabel(field_GasTest__failed)]
    
    syntax GasTestField ::= "IS_SCRIPT" [symbol(), klabel(field_GasTest_IS_SCRIPT)]
    
    syntax GasTestField ::= "stdstore" [symbol(), klabel(field_GasTest_stdstore)]
    
    rule  ( #loc ( GasTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( GasTest . _failed ) => 0 )
      
    
    rule  ( #loc ( GasTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( GasTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= GasTestContract "." GasTestMethod [function(), symbol(), klabel(method_GasTest)]
    
    syntax GasTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_GasTest_IS_SCRIPT)]
    
    syntax GasTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_GasTest_IS_TEST)]
    
    syntax GasTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_GasTest_failed)]
    
    syntax GasTestMethod ::= "kevm" "(" ")" [symbol(), klabel(method_GasTest_kevm)]
    
    syntax GasTestMethod ::= "testInfiniteGas" "(" ")" [symbol(), klabel(method_GasTest_testInfiniteGas)]
    
    syntax GasTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_GasTest_vm)]
    
    rule  ( GasTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( GasTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( GasTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( GasTest . kevm ( ) => #abiCallData ( "kevm" , .TypedArgs ) )
      
    
    rule  ( GasTest . testInfiniteGas ( ) => #abiCallData ( "testInfiniteGas" , .TypedArgs ) )
      
    
    rule  ( GasTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "kevm" ) => 3601001590 )
      
    
    rule  ( selector ( "testInfiniteGas" ) => 1677640502 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module GETCODETEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= GetCodeTestContract
    
    syntax GetCodeTestContract ::= "GetCodeTest" [symbol(), klabel(contract_GetCodeTest)]
    
      
    
    syntax Field ::= GetCodeTestField
    
    syntax GetCodeTestField ::= "IS_TEST" [symbol(), klabel(field_GetCodeTest_IS_TEST)]
    
    syntax GetCodeTestField ::= "_failed" [symbol(), klabel(field_GetCodeTest__failed)]
    
    syntax GetCodeTestField ::= "IS_SCRIPT" [symbol(), klabel(field_GetCodeTest_IS_SCRIPT)]
    
    syntax GetCodeTestField ::= "stdstore" [symbol(), klabel(field_GetCodeTest_stdstore)]
    
    syntax GetCodeTestField ::= "myToken" [symbol(), klabel(field_GetCodeTest_myToken)]
    
    rule  ( #loc ( GetCodeTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( GetCodeTest . _failed ) => 0 )
      
    
    rule  ( #loc ( GetCodeTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( GetCodeTest . stdstore ) => 1 )
      
    
    rule  ( #loc ( GetCodeTest . myToken ) => 8 )
      
    
    syntax Bytes ::= GetCodeTestContract "." GetCodeTestMethod [function(), symbol(), klabel(method_GetCodeTest)]
    
    syntax GetCodeTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_GetCodeTest_IS_SCRIPT)]
    
    syntax GetCodeTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_GetCodeTest_IS_TEST)]
    
    syntax GetCodeTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_GetCodeTest_failed)]
    
    syntax GetCodeTestMethod ::= "setUp" "(" ")" [symbol(), klabel(method_GetCodeTest_setUp)]
    
    syntax GetCodeTestMethod ::= "testGetCode" "(" ")" [symbol(), klabel(method_GetCodeTest_testGetCode)]
    
    syntax GetCodeTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_GetCodeTest_vm)]
    
    rule  ( GetCodeTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( GetCodeTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( GetCodeTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( GetCodeTest . setUp ( ) => #abiCallData ( "setUp" , .TypedArgs ) )
      
    
    rule  ( GetCodeTest . testGetCode ( ) => #abiCallData ( "testGetCode" , .TypedArgs ) )
      
    
    rule  ( GetCodeTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "setUp" ) => 177362148 )
      
    
    rule  ( selector ( "testGetCode" ) => 3906163359 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module KEVMCHEATS-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= KEVMCheatsContract
    
    syntax KEVMCheatsContract ::= "KEVMCheats" [symbol(), klabel(contract_KEVMCheats)]
    
      
    
    syntax Bytes ::= KEVMCheatsContract "." KEVMCheatsMethod [function(), symbol(), klabel(method_KEVMCheats)]
    
    syntax KEVMCheatsMethod ::= "kevm" "(" ")" [symbol(), klabel(method_KEVMCheats_kevm)]
    
    rule  ( KEVMCheats . kevm ( ) => #abiCallData ( "kevm" , .TypedArgs ) )
      
    
    rule  ( selector ( "kevm" ) => 3601001590 )
      

endmodule

module KEVMCHEATSBASE-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= KEVMCheatsBaseContract
    
    syntax KEVMCheatsBaseContract ::= "KEVMCheatsBase" [symbol(), klabel(contract_KEVMCheatsBase)]
    
      
    
    syntax Bytes ::= KEVMCheatsBaseContract "." KEVMCheatsBaseMethod [function(), symbol(), klabel(method_KEVMCheatsBase)]
    
    syntax KEVMCheatsBaseMethod ::= "allowCallsToAddress" "(" Int ")" [symbol(), klabel(method_KEVMCheatsBase_allowCallsToAddress)]
    
    syntax KEVMCheatsBaseMethod ::= "allowChangesToStorage" "(" Int "," Int ")" [symbol(), klabel(method_KEVMCheatsBase_allowChangesToStorage)]
    
    syntax KEVMCheatsBaseMethod ::= "expectCreate" "(" Int "," Int "," Bytes ")" [symbol(), klabel(method_KEVMCheatsBase_expectCreate)]
    
    syntax KEVMCheatsBaseMethod ::= "expectCreate2" "(" Int "," Int "," Bytes ")" [symbol(), klabel(method_KEVMCheatsBase_expectCreate2)]
    
    syntax KEVMCheatsBaseMethod ::= "expectDelegateCall" "(" Int "," Bytes ")" [symbol(), klabel(method_KEVMCheatsBase_expectDelegateCall)]
    
    syntax KEVMCheatsBaseMethod ::= "expectNoCall" "(" ")" [symbol(), klabel(method_KEVMCheatsBase_expectNoCall)]
    
    syntax KEVMCheatsBaseMethod ::= "expectRegularCall" "(" Int "," Int "," Bytes ")" [symbol(), klabel(method_KEVMCheatsBase_expectRegularCall)]
    
    syntax KEVMCheatsBaseMethod ::= "expectRegularCall" "(" Int "," Int "," Bytes ")" [symbol(), klabel(method_KEVMCheatsBase_expectRegularCall)]
    
    syntax KEVMCheatsBaseMethod ::= "expectStaticCall" "(" Int "," Bytes ")" [symbol(), klabel(method_KEVMCheatsBase_expectStaticCall)]
    
    syntax KEVMCheatsBaseMethod ::= "infiniteGas" "(" ")" [symbol(), klabel(method_KEVMCheatsBase_infiniteGas)]
    
    syntax KEVMCheatsBaseMethod ::= "symbolicStorage" "(" Int ")" [symbol(), klabel(method_KEVMCheatsBase_symbolicStorage)]
    
    rule  ( KEVMCheatsBase . allowCallsToAddress ( V0_ ) => #abiCallData ( "allowCallsToAddress" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( KEVMCheatsBase . allowChangesToStorage ( V0_ , V1_ ) => #abiCallData ( "allowChangesToStorage" , #address ( V0_ ) , #uint256 ( V1_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 256 , V1_ )
               ))
      
    
    rule  ( KEVMCheatsBase . expectCreate ( V0_ , V1_ , V2_ ) => #abiCallData ( "expectCreate" , #address ( V0_ ) , #uint256 ( V1_ ) , #bytes ( V2_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 256 , V1_ )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V2_ ) )
               )))
      
    
    rule  ( KEVMCheatsBase . expectCreate2 ( V0_ , V1_ , V2_ ) => #abiCallData ( "expectCreate2" , #address ( V0_ ) , #uint256 ( V1_ ) , #bytes ( V2_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 256 , V1_ )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V2_ ) )
               )))
      
    
    rule  ( KEVMCheatsBase . expectDelegateCall ( V0_ , V1_ ) => #abiCallData ( "expectDelegateCall" , #address ( V0_ ) , #bytes ( V1_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V1_ ) )
               ))
      
    
    rule  ( KEVMCheatsBase . expectNoCall ( ) => #abiCallData ( "expectNoCall" , .TypedArgs ) )
      
    
    rule  ( KEVMCheatsBase . expectRegularCall ( V0_ , V1_ , V2_ ) => #abiCallData ( "expectRegularCall" , #address ( V0_ ) , #uint256 ( V1_ ) , #bytes ( V2_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 256 , V1_ )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V2_ ) )
               )))
      
    
    rule  ( KEVMCheatsBase . expectRegularCall ( V0_ , V1_ , V2_ ) => #abiCallData ( "expectRegularCall" , #address ( V0_ ) , #uint256 ( V1_ ) , #bytes ( V2_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 256 , V1_ )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V2_ ) )
               )))
      
    
    rule  ( KEVMCheatsBase . expectStaticCall ( V0_ , V1_ ) => #abiCallData ( "expectStaticCall" , #address ( V0_ ) , #bytes ( V1_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V1_ ) )
               ))
      
    
    rule  ( KEVMCheatsBase . infiniteGas ( ) => #abiCallData ( "infiniteGas" , .TypedArgs ) )
      
    
    rule  ( KEVMCheatsBase . symbolicStorage ( V0_ ) => #abiCallData ( "symbolicStorage" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( selector ( "allowCallsToAddress" ) => 1850795572 )
      
    
    rule  ( selector ( "allowChangesToStorage" ) => 4207417100 )
      
    
    rule  ( selector ( "expectCreate" ) => 658968394 )
      
    
    rule  ( selector ( "expectCreate2" ) => 3854582462 )
      
    
    rule  ( selector ( "expectDelegateCall" ) => 1030406631 )
      
    
    rule  ( selector ( "expectNoCall" ) => 3861374088 )
      
    
    rule  ( selector ( "expectRegularCall" ) => 3178868520 )
      
    
    rule  ( selector ( "expectRegularCall" ) => 1973496647 )
      
    
    rule  ( selector ( "expectStaticCall" ) => 2232945516 )
      
    
    rule  ( selector ( "infiniteGas" ) => 3986649939 )
      
    
    rule  ( selector ( "symbolicStorage" ) => 769677742 )
      

endmodule

module LABELTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= LabelTestContract
    
    syntax LabelTestContract ::= "LabelTest" [symbol(), klabel(contract_LabelTest)]
    
      
    
    syntax Field ::= LabelTestField
    
    syntax LabelTestField ::= "IS_TEST" [symbol(), klabel(field_LabelTest_IS_TEST)]
    
    syntax LabelTestField ::= "_failed" [symbol(), klabel(field_LabelTest__failed)]
    
    syntax LabelTestField ::= "IS_SCRIPT" [symbol(), klabel(field_LabelTest_IS_SCRIPT)]
    
    syntax LabelTestField ::= "stdstore" [symbol(), klabel(field_LabelTest_stdstore)]
    
    rule  ( #loc ( LabelTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( LabelTest . _failed ) => 0 )
      
    
    rule  ( #loc ( LabelTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( LabelTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= LabelTestContract "." LabelTestMethod [function(), symbol(), klabel(method_LabelTest)]
    
    syntax LabelTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_LabelTest_IS_SCRIPT)]
    
    syntax LabelTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_LabelTest_IS_TEST)]
    
    syntax LabelTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_LabelTest_failed)]
    
    syntax LabelTestMethod ::= "testLabel" "(" ")" [symbol(), klabel(method_LabelTest_testLabel)]
    
    syntax LabelTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_LabelTest_vm)]
    
    rule  ( LabelTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( LabelTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( LabelTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( LabelTest . testLabel ( ) => #abiCallData ( "testLabel" , .TypedArgs ) )
      
    
    rule  ( LabelTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testLabel" ) => 799101117 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module LOOPSTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= LoopsTestContract
    
    syntax LoopsTestContract ::= "LoopsTest" [symbol(), klabel(contract_LoopsTest)]
    
      
    
    syntax Field ::= LoopsTestField
    
    syntax LoopsTestField ::= "IS_TEST" [symbol(), klabel(field_LoopsTest_IS_TEST)]
    
    syntax LoopsTestField ::= "_failed" [symbol(), klabel(field_LoopsTest__failed)]
    
    syntax LoopsTestField ::= "IS_SCRIPT" [symbol(), klabel(field_LoopsTest_IS_SCRIPT)]
    
    syntax LoopsTestField ::= "stdstore" [symbol(), klabel(field_LoopsTest_stdstore)]
    
    rule  ( #loc ( LoopsTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( LoopsTest . _failed ) => 0 )
      
    
    rule  ( #loc ( LoopsTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( LoopsTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= LoopsTestContract "." LoopsTestMethod [function(), symbol(), klabel(method_LoopsTest)]
    
    syntax LoopsTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_LoopsTest_IS_SCRIPT)]
    
    syntax LoopsTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_LoopsTest_IS_TEST)]
    
    syntax LoopsTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_LoopsTest_failed)]
    
    syntax LoopsTestMethod ::= "testIsNotPrime" "(" Int ")" [symbol(), klabel(method_LoopsTest_testIsNotPrime)]
    
    syntax LoopsTestMethod ::= "testIsPrime" "(" Int "," Int ")" [symbol(), klabel(method_LoopsTest_testIsPrime)]
    
    syntax LoopsTestMethod ::= "testIsPrimeBroken" "(" Int "," Int ")" [symbol(), klabel(method_LoopsTest_testIsPrimeBroken)]
    
    syntax LoopsTestMethod ::= "testIsPrimeOpt" "(" Int ")" [symbol(), klabel(method_LoopsTest_testIsPrimeOpt)]
    
    syntax LoopsTestMethod ::= "testMax" "(" K ")" [symbol(), klabel(method_LoopsTest_testMax)]
    
    syntax LoopsTestMethod ::= "testMaxBroken" "(" K ")" [symbol(), klabel(method_LoopsTest_testMaxBroken)]
    
    syntax LoopsTestMethod ::= "testNthPrime" "(" Int "," Int ")" [symbol(), klabel(method_LoopsTest_testNthPrime)]
    
    syntax LoopsTestMethod ::= "testSort" "(" K ")" [symbol(), klabel(method_LoopsTest_testSort)]
    
    syntax LoopsTestMethod ::= "testSortBroken" "(" K ")" [symbol(), klabel(method_LoopsTest_testSortBroken)]
    
    syntax LoopsTestMethod ::= "testSqrt" "(" Int ")" [symbol(), klabel(method_LoopsTest_testSqrt)]
    
    syntax LoopsTestMethod ::= "testSumToN" "(" Int ")" [symbol(), klabel(method_LoopsTest_testSumToN)]
    
    syntax LoopsTestMethod ::= "testSumToNBroken" "(" Int ")" [symbol(), klabel(method_LoopsTest_testSumToNBroken)]
    
    syntax LoopsTestMethod ::= "test_sum_10" "(" ")" [symbol(), klabel(method_LoopsTest_test_sum_10)]
    
    syntax LoopsTestMethod ::= "test_sum_100" "(" ")" [symbol(), klabel(method_LoopsTest_test_sum_100)]
    
    syntax LoopsTestMethod ::= "test_sum_1000" "(" ")" [symbol(), klabel(method_LoopsTest_test_sum_1000)]
    
    syntax LoopsTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_LoopsTest_vm)]
    
    rule  ( LoopsTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( LoopsTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( LoopsTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( LoopsTest . testIsNotPrime ( V0_n ) => #abiCallData ( "testIsNotPrime" , #uint256 ( V0_n ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_n )
      
    
    rule  ( LoopsTest . testIsPrime ( V0_n , V1_i ) => #abiCallData ( "testIsPrime" , #uint256 ( V0_n ) , #uint256 ( V1_i ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_n )
       andBool ( #rangeUInt ( 256 , V1_i )
               ))
      
    
    rule  ( LoopsTest . testIsPrimeBroken ( V0_n , V1_i ) => #abiCallData ( "testIsPrimeBroken" , #uint256 ( V0_n ) , #uint256 ( V1_i ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_n )
       andBool ( #rangeUInt ( 256 , V1_i )
               ))
      
    
    rule  ( LoopsTest . testIsPrimeOpt ( V0_n ) => #abiCallData ( "testIsPrimeOpt" , #uint256 ( V0_n ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_n )
      
    
    rule  ( LoopsTest . testNthPrime ( V0_n , V1_i ) => #abiCallData ( "testNthPrime" , #uint256 ( V0_n ) , #uint256 ( V1_i ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_n )
       andBool ( #rangeUInt ( 256 , V1_i )
               ))
      
    
    rule  ( LoopsTest . testSqrt ( V0_x ) => #abiCallData ( "testSqrt" , #uint256 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( LoopsTest . testSumToN ( V0_n ) => #abiCallData ( "testSumToN" , #uint256 ( V0_n ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_n )
      
    
    rule  ( LoopsTest . testSumToNBroken ( V0_n ) => #abiCallData ( "testSumToNBroken" , #uint256 ( V0_n ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_n )
      
    
    rule  ( LoopsTest . test_sum_10 ( ) => #abiCallData ( "test_sum_10" , .TypedArgs ) )
      
    
    rule  ( LoopsTest . test_sum_100 ( ) => #abiCallData ( "test_sum_100" , .TypedArgs ) )
      
    
    rule  ( LoopsTest . test_sum_1000 ( ) => #abiCallData ( "test_sum_1000" , .TypedArgs ) )
      
    
    rule  ( LoopsTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testIsNotPrime" ) => 809987623 )
      
    
    rule  ( selector ( "testIsPrime" ) => 111940912 )
      
    
    rule  ( selector ( "testIsPrimeBroken" ) => 1834826207 )
      
    
    rule  ( selector ( "testIsPrimeOpt" ) => 404719852 )
      
    
    rule  ( selector ( "testMax" ) => 1575104263 )
      
    
    rule  ( selector ( "testMaxBroken" ) => 1372438930 )
      
    
    rule  ( selector ( "testNthPrime" ) => 2702762242 )
      
    
    rule  ( selector ( "testSort" ) => 2414037741 )
      
    
    rule  ( selector ( "testSortBroken" ) => 3541275661 )
      
    
    rule  ( selector ( "testSqrt" ) => 233106198 )
      
    
    rule  ( selector ( "testSumToN" ) => 2289979355 )
      
    
    rule  ( selector ( "testSumToNBroken" ) => 1318374999 )
      
    
    rule  ( selector ( "test_sum_10" ) => 1087009050 )
      
    
    rule  ( selector ( "test_sum_100" ) => 1519953344 )
      
    
    rule  ( selector ( "test_sum_1000" ) => 222767225 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module MOCKCALLTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= MockCallTestContract
    
    syntax MockCallTestContract ::= "MockCallTest" [symbol(), klabel(contract_MockCallTest)]
    
      
    
    syntax Field ::= MockCallTestField
    
    syntax MockCallTestField ::= "IS_TEST" [symbol(), klabel(field_MockCallTest_IS_TEST)]
    
    syntax MockCallTestField ::= "_failed" [symbol(), klabel(field_MockCallTest__failed)]
    
    syntax MockCallTestField ::= "IS_SCRIPT" [symbol(), klabel(field_MockCallTest_IS_SCRIPT)]
    
    syntax MockCallTestField ::= "stdstore" [symbol(), klabel(field_MockCallTest_stdstore)]
    
    rule  ( #loc ( MockCallTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( MockCallTest . _failed ) => 0 )
      
    
    rule  ( #loc ( MockCallTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( MockCallTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= MockCallTestContract "." MockCallTestMethod [function(), symbol(), klabel(method_MockCallTest)]
    
    syntax MockCallTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_MockCallTest_IS_SCRIPT)]
    
    syntax MockCallTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_MockCallTest_IS_TEST)]
    
    syntax MockCallTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_MockCallTest_failed)]
    
    syntax MockCallTestMethod ::= "testMockCall" "(" ")" [symbol(), klabel(method_MockCallTest_testMockCall)]
    
    syntax MockCallTestMethod ::= "testMockCallValue" "(" ")" [symbol(), klabel(method_MockCallTest_testMockCallValue)]
    
    syntax MockCallTestMethod ::= "testMockCalls" "(" ")" [symbol(), klabel(method_MockCallTest_testMockCalls)]
    
    syntax MockCallTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_MockCallTest_vm)]
    
    rule  ( MockCallTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( MockCallTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( MockCallTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( MockCallTest . testMockCall ( ) => #abiCallData ( "testMockCall" , .TypedArgs ) )
      
    
    rule  ( MockCallTest . testMockCallValue ( ) => #abiCallData ( "testMockCallValue" , .TypedArgs ) )
      
    
    rule  ( MockCallTest . testMockCalls ( ) => #abiCallData ( "testMockCalls" , .TypedArgs ) )
      
    
    rule  ( MockCallTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testMockCall" ) => 3143830108 )
      
    
    rule  ( selector ( "testMockCallValue" ) => 1208641942 )
      
    
    rule  ( selector ( "testMockCalls" ) => 957910350 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module MYIERC20-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= MyIERC20Contract
    
    syntax MyIERC20Contract ::= "MyIERC20" [symbol(), klabel(contract_MyIERC20)]
    
      
    
    syntax Bytes ::= MyIERC20Contract "." MyIERC20Method [function(), symbol(), klabel(method_MyIERC20)]
    
    syntax MyIERC20Method ::= "approve" "(" Int "," Int ")" [symbol(), klabel(method_MyIERC20_approve)]
    
    syntax MyIERC20Method ::= "balanceOf" "(" Int ")" [symbol(), klabel(method_MyIERC20_balanceOf)]
    
    syntax MyIERC20Method ::= "decimals" "(" ")" [symbol(), klabel(method_MyIERC20_decimals)]
    
    syntax MyIERC20Method ::= "symbol" "(" ")" [symbol(), klabel(method_MyIERC20_symbol)]
    
    syntax MyIERC20Method ::= "totalSupply" "(" ")" [symbol(), klabel(method_MyIERC20_totalSupply)]
    
    syntax MyIERC20Method ::= "transfer" "(" Int "," Int ")" [symbol(), klabel(method_MyIERC20_transfer)]
    
    syntax MyIERC20Method ::= "transferFrom" "(" Int "," Int "," Int ")" [symbol(), klabel(method_MyIERC20_transferFrom)]
    
    rule  ( MyIERC20 . approve ( V0_spender , V1_value ) => #abiCallData ( "approve" , #address ( V0_spender ) , #uint256 ( V1_value ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_spender )
       andBool ( #rangeUInt ( 256 , V1_value )
               ))
      
    
    rule  ( MyIERC20 . balanceOf ( V0_ ) => #abiCallData ( "balanceOf" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( MyIERC20 . decimals ( ) => #abiCallData ( "decimals" , .TypedArgs ) )
      
    
    rule  ( MyIERC20 . symbol ( ) => #abiCallData ( "symbol" , .TypedArgs ) )
      
    
    rule  ( MyIERC20 . totalSupply ( ) => #abiCallData ( "totalSupply" , .TypedArgs ) )
      
    
    rule  ( MyIERC20 . transfer ( V0_recipient , V1_amount ) => #abiCallData ( "transfer" , #address ( V0_recipient ) , #uint256 ( V1_amount ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_recipient )
       andBool ( #rangeUInt ( 256 , V1_amount )
               ))
      
    
    rule  ( MyIERC20 . transferFrom ( V0_sender , V1_recipient , V2_amount ) => #abiCallData ( "transferFrom" , #address ( V0_sender ) , #address ( V1_recipient ) , #uint256 ( V2_amount ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_sender )
       andBool ( #rangeAddress ( V1_recipient )
       andBool ( #rangeUInt ( 256 , V2_amount )
               )))
      
    
    rule  ( selector ( "approve" ) => 157198259 )
      
    
    rule  ( selector ( "balanceOf" ) => 1889567281 )
      
    
    rule  ( selector ( "decimals" ) => 826074471 )
      
    
    rule  ( selector ( "symbol" ) => 2514000705 )
      
    
    rule  ( selector ( "totalSupply" ) => 404098525 )
      
    
    rule  ( selector ( "transfer" ) => 2835717307 )
      
    
    rule  ( selector ( "transferFrom" ) => 599290589 )
      

endmodule

module MYTOKEN-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= MyTokenContract
    
    syntax MyTokenContract ::= "MyToken" [symbol(), klabel(contract_MyToken)]
    
      
    
    syntax Field ::= MyTokenField
    
    syntax MyTokenField ::= "token" [symbol(), klabel(field_MyToken_token)]
    
    syntax MyTokenField ::= "balances" [symbol(), klabel(field_MyToken_balances)]
    
    rule  ( #loc ( MyToken . token ) => 0 )
      
    
    rule  ( #loc ( MyToken . balances ) => 1 )
      
    
    syntax Bytes ::= MyTokenContract "." MyTokenMethod [function(), symbol(), klabel(method_MyToken)]
    
    syntax MyTokenMethod ::= "balanceOf" "(" Int ")" [symbol(), klabel(method_MyToken_balanceOf)]
    
    syntax MyTokenMethod ::= "balances" "(" Int ")" [symbol(), klabel(method_MyToken_balances)]
    
    syntax MyTokenMethod ::= "pay" "(" Int ")" [symbol(), klabel(method_MyToken_pay)]
    
    syntax MyTokenMethod ::= "token" "(" ")" [symbol(), klabel(method_MyToken_token)]
    
    rule  ( MyToken . balanceOf ( V0_user ) => #abiCallData ( "balanceOf" , #address ( V0_user ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_user )
      
    
    rule  ( MyToken . balances ( V0_ ) => #abiCallData ( "balances" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( MyToken . pay ( V0_user ) => #abiCallData ( "pay" , #address ( V0_user ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_user )
      
    
    rule  ( MyToken . token ( ) => #abiCallData ( "token" , .TypedArgs ) )
      
    
    rule  ( selector ( "balanceOf" ) => 1889567281 )
      
    
    rule  ( selector ( "balances" ) => 669136355 )
      
    
    rule  ( selector ( "pay" ) => 202497757 )
      
    
    rule  ( selector ( "token" ) => 4228666474 )
      

endmodule

module NOIMPORT-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= NoImportContract
    
    syntax NoImportContract ::= "NoImport" [symbol(), klabel(contract_NoImport)]
    
      
    
    syntax Bytes ::= NoImportContract "." NoImportMethod [function(), symbol(), klabel(method_NoImport)]
    
    syntax NoImportMethod ::= "test_source_map" "(" ")" [symbol(), klabel(method_NoImport_test_source_map)]
    
    rule  ( NoImport . test_source_map ( ) => #abiCallData ( "test_source_map" , .TypedArgs ) )
      
    
    rule  ( selector ( "test_source_map" ) => 3563497491 )
      

endmodule

module OWNERUPONLY-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= OwnerUpOnlyContract
    
    syntax OwnerUpOnlyContract ::= "OwnerUpOnly" [symbol(), klabel(contract_OwnerUpOnly)]
    
      
    
    syntax Field ::= OwnerUpOnlyField
    
    syntax OwnerUpOnlyField ::= "count" [symbol(), klabel(field_OwnerUpOnly_count)]
    
    rule  ( #loc ( OwnerUpOnly . count ) => 0 )
      
    
    syntax Bytes ::= OwnerUpOnlyContract "." OwnerUpOnlyMethod [function(), symbol(), klabel(method_OwnerUpOnly)]
    
    syntax OwnerUpOnlyMethod ::= "count" "(" ")" [symbol(), klabel(method_OwnerUpOnly_count)]
    
    syntax OwnerUpOnlyMethod ::= "increment" "(" ")" [symbol(), klabel(method_OwnerUpOnly_increment)]
    
    syntax OwnerUpOnlyMethod ::= "owner" "(" ")" [symbol(), klabel(method_OwnerUpOnly_owner)]
    
    rule  ( OwnerUpOnly . count ( ) => #abiCallData ( "count" , .TypedArgs ) )
      
    
    rule  ( OwnerUpOnly . increment ( ) => #abiCallData ( "increment" , .TypedArgs ) )
      
    
    rule  ( OwnerUpOnly . owner ( ) => #abiCallData ( "owner" , .TypedArgs ) )
      
    
    rule  ( selector ( "count" ) => 107354813 )
      
    
    rule  ( selector ( "increment" ) => 3500007562 )
      
    
    rule  ( selector ( "owner" ) => 2376452955 )
      

endmodule

module OWNERUPONLYTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= OwnerUpOnlyTestContract
    
    syntax OwnerUpOnlyTestContract ::= "OwnerUpOnlyTest" [symbol(), klabel(contract_OwnerUpOnlyTest)]
    
      
    
    syntax Field ::= OwnerUpOnlyTestField
    
    syntax OwnerUpOnlyTestField ::= "IS_TEST" [symbol(), klabel(field_OwnerUpOnlyTest_IS_TEST)]
    
    syntax OwnerUpOnlyTestField ::= "_failed" [symbol(), klabel(field_OwnerUpOnlyTest__failed)]
    
    syntax OwnerUpOnlyTestField ::= "IS_SCRIPT" [symbol(), klabel(field_OwnerUpOnlyTest_IS_SCRIPT)]
    
    syntax OwnerUpOnlyTestField ::= "stdstore" [symbol(), klabel(field_OwnerUpOnlyTest_stdstore)]
    
    syntax OwnerUpOnlyTestField ::= "upOnly" [symbol(), klabel(field_OwnerUpOnlyTest_upOnly)]
    
    rule  ( #loc ( OwnerUpOnlyTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( OwnerUpOnlyTest . _failed ) => 0 )
      
    
    rule  ( #loc ( OwnerUpOnlyTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( OwnerUpOnlyTest . stdstore ) => 1 )
      
    
    rule  ( #loc ( OwnerUpOnlyTest . upOnly ) => 8 )
      
    
    syntax Bytes ::= OwnerUpOnlyTestContract "." OwnerUpOnlyTestMethod [function(), symbol(), klabel(method_OwnerUpOnlyTest)]
    
    syntax OwnerUpOnlyTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_OwnerUpOnlyTest_IS_SCRIPT)]
    
    syntax OwnerUpOnlyTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_OwnerUpOnlyTest_IS_TEST)]
    
    syntax OwnerUpOnlyTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_OwnerUpOnlyTest_failed)]
    
    syntax OwnerUpOnlyTestMethod ::= "setUp" "(" ")" [symbol(), klabel(method_OwnerUpOnlyTest_setUp)]
    
    syntax OwnerUpOnlyTestMethod ::= "testFailIncrementAsNotOwner" "(" ")" [symbol(), klabel(method_OwnerUpOnlyTest_testFailIncrementAsNotOwner)]
    
    syntax OwnerUpOnlyTestMethod ::= "testIncrementAsNotOwner" "(" ")" [symbol(), klabel(method_OwnerUpOnlyTest_testIncrementAsNotOwner)]
    
    syntax OwnerUpOnlyTestMethod ::= "testIncrementAsOwner" "(" ")" [symbol(), klabel(method_OwnerUpOnlyTest_testIncrementAsOwner)]
    
    syntax OwnerUpOnlyTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_OwnerUpOnlyTest_vm)]
    
    rule  ( OwnerUpOnlyTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( OwnerUpOnlyTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( OwnerUpOnlyTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( OwnerUpOnlyTest . setUp ( ) => #abiCallData ( "setUp" , .TypedArgs ) )
      
    
    rule  ( OwnerUpOnlyTest . testFailIncrementAsNotOwner ( ) => #abiCallData ( "testFailIncrementAsNotOwner" , .TypedArgs ) )
      
    
    rule  ( OwnerUpOnlyTest . testIncrementAsNotOwner ( ) => #abiCallData ( "testIncrementAsNotOwner" , .TypedArgs ) )
      
    
    rule  ( OwnerUpOnlyTest . testIncrementAsOwner ( ) => #abiCallData ( "testIncrementAsOwner" , .TypedArgs ) )
      
    
    rule  ( OwnerUpOnlyTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "setUp" ) => 177362148 )
      
    
    rule  ( selector ( "testFailIncrementAsNotOwner" ) => 4249919617 )
      
    
    rule  ( selector ( "testIncrementAsNotOwner" ) => 1302326069 )
      
    
    rule  ( selector ( "testIncrementAsOwner" ) => 1980498343 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module ADDITIONALTOKEN-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= AdditionalTokenContract
    
    syntax AdditionalTokenContract ::= "AdditionalToken" [symbol(), klabel(contract_AdditionalToken)]
    
      
    
    syntax Field ::= AdditionalTokenField
    
    syntax AdditionalTokenField ::= "count" [symbol(), klabel(field_AdditionalToken_count)]
    
    rule  ( #loc ( AdditionalToken . count ) => 0 )
      
    
    syntax Bytes ::= AdditionalTokenContract "." AdditionalTokenMethod [function(), symbol(), klabel(method_AdditionalToken)]
    
    syntax AdditionalTokenMethod ::= "count" "(" ")" [symbol(), klabel(method_AdditionalToken_count)]
    
    syntax AdditionalTokenMethod ::= "incrementCount" "(" ")" [symbol(), klabel(method_AdditionalToken_incrementCount)]
    
    syntax AdditionalTokenMethod ::= "owner" "(" ")" [symbol(), klabel(method_AdditionalToken_owner)]
    
    rule  ( AdditionalToken . count ( ) => #abiCallData ( "count" , .TypedArgs ) )
      
    
    rule  ( AdditionalToken . incrementCount ( ) => #abiCallData ( "incrementCount" , .TypedArgs ) )
      
    
    rule  ( AdditionalToken . owner ( ) => #abiCallData ( "owner" , .TypedArgs ) )
      
    
    rule  ( selector ( "count" ) => 107354813 )
      
    
    rule  ( selector ( "incrementCount" ) => 3842448270 )
      
    
    rule  ( selector ( "owner" ) => 2376452955 )
      

endmodule

module PLAINPRANKTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= PlainPrankTestContract
    
    syntax PlainPrankTestContract ::= "PlainPrankTest" [symbol(), klabel(contract_PlainPrankTest)]
    
      
    
    syntax Field ::= PlainPrankTestField
    
    syntax PlainPrankTestField ::= "IS_TEST" [symbol(), klabel(field_PlainPrankTest_IS_TEST)]
    
    syntax PlainPrankTestField ::= "_failed" [symbol(), klabel(field_PlainPrankTest__failed)]
    
    syntax PlainPrankTestField ::= "IS_SCRIPT" [symbol(), klabel(field_PlainPrankTest_IS_SCRIPT)]
    
    syntax PlainPrankTestField ::= "stdstore" [symbol(), klabel(field_PlainPrankTest_stdstore)]
    
    rule  ( #loc ( PlainPrankTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( PlainPrankTest . _failed ) => 0 )
      
    
    rule  ( #loc ( PlainPrankTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( PlainPrankTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= PlainPrankTestContract "." PlainPrankTestMethod [function(), symbol(), klabel(method_PlainPrankTest)]
    
    syntax PlainPrankTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_PlainPrankTest_IS_SCRIPT)]
    
    syntax PlainPrankTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_PlainPrankTest_IS_TEST)]
    
    syntax PlainPrankTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_PlainPrankTest_failed)]
    
    syntax PlainPrankTestMethod ::= "internalCounter" "(" ")" [symbol(), klabel(method_PlainPrankTest_internalCounter)]
    
    syntax PlainPrankTestMethod ::= "testFail_startPrank_existingAlready" "(" ")" [symbol(), klabel(method_PlainPrankTest_testFail_startPrank_existingAlready)]
    
    syntax PlainPrankTestMethod ::= "testFail_startPrank_internalCall" "(" ")" [symbol(), klabel(method_PlainPrankTest_testFail_startPrank_internalCall)]
    
    syntax PlainPrankTestMethod ::= "test_prank_zeroAddress_true" "(" ")" [symbol(), klabel(method_PlainPrankTest_test_prank_zeroAddress_true)]
    
    syntax PlainPrankTestMethod ::= "test_startPrankWithOrigin_true" "(" ")" [symbol(), klabel(method_PlainPrankTest_test_startPrankWithOrigin_true)]
    
    syntax PlainPrankTestMethod ::= "test_startPrank_true" "(" ")" [symbol(), klabel(method_PlainPrankTest_test_startPrank_true)]
    
    syntax PlainPrankTestMethod ::= "test_startPrank_zeroAddress_true" "(" ")" [symbol(), klabel(method_PlainPrankTest_test_startPrank_zeroAddress_true)]
    
    syntax PlainPrankTestMethod ::= "test_stopPrank_notExistent" "(" ")" [symbol(), klabel(method_PlainPrankTest_test_stopPrank_notExistent)]
    
    syntax PlainPrankTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_PlainPrankTest_vm)]
    
    rule  ( PlainPrankTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( PlainPrankTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( PlainPrankTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( PlainPrankTest . internalCounter ( ) => #abiCallData ( "internalCounter" , .TypedArgs ) )
      
    
    rule  ( PlainPrankTest . testFail_startPrank_existingAlready ( ) => #abiCallData ( "testFail_startPrank_existingAlready" , .TypedArgs ) )
      
    
    rule  ( PlainPrankTest . testFail_startPrank_internalCall ( ) => #abiCallData ( "testFail_startPrank_internalCall" , .TypedArgs ) )
      
    
    rule  ( PlainPrankTest . test_prank_zeroAddress_true ( ) => #abiCallData ( "test_prank_zeroAddress_true" , .TypedArgs ) )
      
    
    rule  ( PlainPrankTest . test_startPrankWithOrigin_true ( ) => #abiCallData ( "test_startPrankWithOrigin_true" , .TypedArgs ) )
      
    
    rule  ( PlainPrankTest . test_startPrank_true ( ) => #abiCallData ( "test_startPrank_true" , .TypedArgs ) )
      
    
    rule  ( PlainPrankTest . test_startPrank_zeroAddress_true ( ) => #abiCallData ( "test_startPrank_zeroAddress_true" , .TypedArgs ) )
      
    
    rule  ( PlainPrankTest . test_stopPrank_notExistent ( ) => #abiCallData ( "test_stopPrank_notExistent" , .TypedArgs ) )
      
    
    rule  ( PlainPrankTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "internalCounter" ) => 2687914858 )
      
    
    rule  ( selector ( "testFail_startPrank_existingAlready" ) => 2262269573 )
      
    
    rule  ( selector ( "testFail_startPrank_internalCall" ) => 3075676477 )
      
    
    rule  ( selector ( "test_prank_zeroAddress_true" ) => 3793950116 )
      
    
    rule  ( selector ( "test_startPrankWithOrigin_true" ) => 1559633499 )
      
    
    rule  ( selector ( "test_startPrank_true" ) => 243527947 )
      
    
    rule  ( selector ( "test_startPrank_zeroAddress_true" ) => 858618957 )
      
    
    rule  ( selector ( "test_stopPrank_notExistent" ) => 279002555 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module PRANK-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= PrankContract
    
    syntax PrankContract ::= "Prank" [symbol(), klabel(contract_Prank)]
    
      
    
    syntax Field ::= PrankField
    
    syntax PrankField ::= "count" [symbol(), klabel(field_Prank_count)]
    
    rule  ( #loc ( Prank . count ) => 0 )
      
    
    syntax Bytes ::= PrankContract "." PrankMethod [function(), symbol(), klabel(method_Prank)]
    
    syntax PrankMethod ::= "add" "(" Int ")" [symbol(), klabel(method_Prank_add)]
    
    syntax PrankMethod ::= "count" "(" ")" [symbol(), klabel(method_Prank_count)]
    
    syntax PrankMethod ::= "owner" "(" ")" [symbol(), klabel(method_Prank_owner)]
    
    syntax PrankMethod ::= "subtract" "(" Int ")" [symbol(), klabel(method_Prank_subtract)]
    
    rule  ( Prank . add ( V0_value ) => #abiCallData ( "add" , #uint256 ( V0_value ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_value )
      
    
    rule  ( Prank . count ( ) => #abiCallData ( "count" , .TypedArgs ) )
      
    
    rule  ( Prank . owner ( ) => #abiCallData ( "owner" , .TypedArgs ) )
      
    
    rule  ( Prank . subtract ( V0_value ) => #abiCallData ( "subtract" , #uint256 ( V0_value ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_value )
      
    
    rule  ( selector ( "add" ) => 268690130 )
      
    
    rule  ( selector ( "count" ) => 107354813 )
      
    
    rule  ( selector ( "owner" ) => 2376452955 )
      
    
    rule  ( selector ( "subtract" ) => 499146519 )
      

endmodule

module PRANKTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= PrankTestContract
    
    syntax PrankTestContract ::= "PrankTest" [symbol(), klabel(contract_PrankTest)]
    
      
    
    syntax Field ::= PrankTestField
    
    syntax PrankTestField ::= "IS_TEST" [symbol(), klabel(field_PrankTest_IS_TEST)]
    
    syntax PrankTestField ::= "_failed" [symbol(), klabel(field_PrankTest__failed)]
    
    syntax PrankTestField ::= "IS_SCRIPT" [symbol(), klabel(field_PrankTest_IS_SCRIPT)]
    
    syntax PrankTestField ::= "stdstore" [symbol(), klabel(field_PrankTest_stdstore)]
    
    syntax PrankTestField ::= "prankContract" [symbol(), klabel(field_PrankTest_prankContract)]
    
    rule  ( #loc ( PrankTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( PrankTest . _failed ) => 0 )
      
    
    rule  ( #loc ( PrankTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( PrankTest . stdstore ) => 1 )
      
    
    rule  ( #loc ( PrankTest . prankContract ) => 8 )
      
    
    syntax Bytes ::= PrankTestContract "." PrankTestMethod [function(), symbol(), klabel(method_PrankTest)]
    
    syntax PrankTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_PrankTest_IS_SCRIPT)]
    
    syntax PrankTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_PrankTest_IS_TEST)]
    
    syntax PrankTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_PrankTest_failed)]
    
    syntax PrankTestMethod ::= "setUp" "(" ")" [symbol(), klabel(method_PrankTest_setUp)]
    
    syntax PrankTestMethod ::= "testAddAsOwner" "(" Int ")" [symbol(), klabel(method_PrankTest_testAddAsOwner)]
    
    syntax PrankTestMethod ::= "testAddStartPrank" "(" Int ")" [symbol(), klabel(method_PrankTest_testAddStartPrank)]
    
    syntax PrankTestMethod ::= "testFailAddPrank" "(" Int ")" [symbol(), klabel(method_PrankTest_testFailAddPrank)]
    
    syntax PrankTestMethod ::= "testSubtractAsTxOrigin" "(" Int "," Int ")" [symbol(), klabel(method_PrankTest_testSubtractAsTxOrigin)]
    
    syntax PrankTestMethod ::= "testSubtractFail" "(" Int ")" [symbol(), klabel(method_PrankTest_testSubtractFail)]
    
    syntax PrankTestMethod ::= "testSubtractStartPrank" "(" Int "," Int ")" [symbol(), klabel(method_PrankTest_testSubtractStartPrank)]
    
    syntax PrankTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_PrankTest_vm)]
    
    rule  ( PrankTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( PrankTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( PrankTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( PrankTest . setUp ( ) => #abiCallData ( "setUp" , .TypedArgs ) )
      
    
    rule  ( PrankTest . testAddAsOwner ( V0_x ) => #abiCallData ( "testAddAsOwner" , #uint256 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( PrankTest . testAddStartPrank ( V0_x ) => #abiCallData ( "testAddStartPrank" , #uint256 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( PrankTest . testFailAddPrank ( V0_x ) => #abiCallData ( "testFailAddPrank" , #uint256 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( PrankTest . testSubtractAsTxOrigin ( V0_addValue , V1_subValue ) => #abiCallData ( "testSubtractAsTxOrigin" , #uint256 ( V0_addValue ) , #uint256 ( V1_subValue ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_addValue )
       andBool ( #rangeUInt ( 256 , V1_subValue )
               ))
      
    
    rule  ( PrankTest . testSubtractFail ( V0_x ) => #abiCallData ( "testSubtractFail" , #uint256 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( PrankTest . testSubtractStartPrank ( V0_addValue , V1_subValue ) => #abiCallData ( "testSubtractStartPrank" , #uint256 ( V0_addValue ) , #uint256 ( V1_subValue ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_addValue )
       andBool ( #rangeUInt ( 256 , V1_subValue )
               ))
      
    
    rule  ( PrankTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "setUp" ) => 177362148 )
      
    
    rule  ( selector ( "testAddAsOwner" ) => 1600382513 )
      
    
    rule  ( selector ( "testAddStartPrank" ) => 1333759955 )
      
    
    rule  ( selector ( "testFailAddPrank" ) => 948023622 )
      
    
    rule  ( selector ( "testSubtractAsTxOrigin" ) => 3798952319 )
      
    
    rule  ( selector ( "testSubtractFail" ) => 1433390937 )
      
    
    rule  ( selector ( "testSubtractStartPrank" ) => 262874110 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module RECORDLOGSTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= RecordLogsTestContract
    
    syntax RecordLogsTestContract ::= "RecordLogsTest" [symbol(), klabel(contract_RecordLogsTest)]
    
      
    
    syntax Field ::= RecordLogsTestField
    
    syntax RecordLogsTestField ::= "IS_TEST" [symbol(), klabel(field_RecordLogsTest_IS_TEST)]
    
    syntax RecordLogsTestField ::= "_failed" [symbol(), klabel(field_RecordLogsTest__failed)]
    
    syntax RecordLogsTestField ::= "IS_SCRIPT" [symbol(), klabel(field_RecordLogsTest_IS_SCRIPT)]
    
    syntax RecordLogsTestField ::= "stdstore" [symbol(), klabel(field_RecordLogsTest_stdstore)]
    
    syntax RecordLogsTestField ::= "emitter" [symbol(), klabel(field_RecordLogsTest_emitter)]
    
    rule  ( #loc ( RecordLogsTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( RecordLogsTest . _failed ) => 0 )
      
    
    rule  ( #loc ( RecordLogsTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( RecordLogsTest . stdstore ) => 1 )
      
    
    rule  ( #loc ( RecordLogsTest . emitter ) => 8 )
      
    
    syntax Bytes ::= RecordLogsTestContract "." RecordLogsTestMethod [function(), symbol(), klabel(method_RecordLogsTest)]
    
    syntax RecordLogsTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_RecordLogsTest_IS_SCRIPT)]
    
    syntax RecordLogsTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_RecordLogsTest_IS_TEST)]
    
    syntax RecordLogsTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_RecordLogsTest_failed)]
    
    syntax RecordLogsTestMethod ::= "setUp" "(" ")" [symbol(), klabel(method_RecordLogsTest_setUp)]
    
    syntax RecordLogsTestMethod ::= "testRecordLogs" "(" ")" [symbol(), klabel(method_RecordLogsTest_testRecordLogs)]
    
    syntax RecordLogsTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_RecordLogsTest_vm)]
    
    rule  ( RecordLogsTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( RecordLogsTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( RecordLogsTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( RecordLogsTest . setUp ( ) => #abiCallData ( "setUp" , .TypedArgs ) )
      
    
    rule  ( RecordLogsTest . testRecordLogs ( ) => #abiCallData ( "testRecordLogs" , .TypedArgs ) )
      
    
    rule  ( RecordLogsTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "setUp" ) => 177362148 )
      
    
    rule  ( selector ( "testRecordLogs" ) => 3623393624 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module SAFE-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= SafeContract
    
    syntax SafeContract ::= "Safe" [symbol(), klabel(contract_Safe)]
    
      
    
    syntax Bytes ::= SafeContract "." SafeMethod [function(), symbol(), klabel(method_Safe)]
    
    syntax SafeMethod ::= "withdraw" "(" ")" [symbol(), klabel(method_Safe_withdraw)]
    
    rule  ( Safe . withdraw ( ) => #abiCallData ( "withdraw" , .TypedArgs ) )
      
    
    rule  ( selector ( "withdraw" ) => 1020253707 )
      

endmodule

module SAFETEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= SafeTestContract
    
    syntax SafeTestContract ::= "SafeTest" [symbol(), klabel(contract_SafeTest)]
    
      
    
    syntax Field ::= SafeTestField
    
    syntax SafeTestField ::= "IS_TEST" [symbol(), klabel(field_SafeTest_IS_TEST)]
    
    syntax SafeTestField ::= "_failed" [symbol(), klabel(field_SafeTest__failed)]
    
    syntax SafeTestField ::= "IS_SCRIPT" [symbol(), klabel(field_SafeTest_IS_SCRIPT)]
    
    syntax SafeTestField ::= "stdstore" [symbol(), klabel(field_SafeTest_stdstore)]
    
    syntax SafeTestField ::= "safe" [symbol(), klabel(field_SafeTest_safe)]
    
    rule  ( #loc ( SafeTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( SafeTest . _failed ) => 0 )
      
    
    rule  ( #loc ( SafeTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( SafeTest . stdstore ) => 1 )
      
    
    rule  ( #loc ( SafeTest . safe ) => 8 )
      
    
    syntax Bytes ::= SafeTestContract "." SafeTestMethod [function(), symbol(), klabel(method_SafeTest)]
    
    syntax SafeTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_SafeTest_IS_SCRIPT)]
    
    syntax SafeTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_SafeTest_IS_TEST)]
    
    syntax SafeTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_SafeTest_failed)]
    
    syntax SafeTestMethod ::= "setUp" "(" ")" [symbol(), klabel(method_SafeTest_setUp)]
    
    syntax SafeTestMethod ::= "testWithdraw" "(" ")" [symbol(), klabel(method_SafeTest_testWithdraw)]
    
    syntax SafeTestMethod ::= "testWithdrawFuzz" "(" Int ")" [symbol(), klabel(method_SafeTest_testWithdrawFuzz)]
    
    syntax SafeTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_SafeTest_vm)]
    
    rule  ( SafeTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( SafeTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( SafeTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( SafeTest . setUp ( ) => #abiCallData ( "setUp" , .TypedArgs ) )
      
    
    rule  ( SafeTest . testWithdraw ( ) => #abiCallData ( "testWithdraw" , .TypedArgs ) )
      
    
    rule  ( SafeTest . testWithdrawFuzz ( V0_amount ) => #abiCallData ( "testWithdrawFuzz" , #uint96 ( V0_amount ) , .TypedArgs ) )
       ensures #rangeUInt ( 96 , V0_amount )
      
    
    rule  ( SafeTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "setUp" ) => 177362148 )
      
    
    rule  ( selector ( "testWithdraw" ) => 3574182252 )
      
    
    rule  ( selector ( "testWithdrawFuzz" ) => 3503970826 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module SCRIPT-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ScriptContract
    
    syntax ScriptContract ::= "Script" [symbol(), klabel(contract_Script)]
    
      
    
    syntax Field ::= ScriptField
    
    syntax ScriptField ::= "IS_SCRIPT" [symbol(), klabel(field_Script_IS_SCRIPT)]
    
    rule  ( #loc ( Script . IS_SCRIPT ) => 0 )
      
    
    syntax Bytes ::= ScriptContract "." ScriptMethod [function(), symbol(), klabel(method_Script)]
    
    syntax ScriptMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_Script_IS_SCRIPT)]
    
    syntax ScriptMethod ::= "vm" "(" ")" [symbol(), klabel(method_Script_vm)]
    
    rule  ( Script . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( Script . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module SETUP2TEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= Setup2TestContract
    
    syntax Setup2TestContract ::= "Setup2Test" [symbol(), klabel(contract_Setup2Test)]
    
      
    
    syntax Field ::= Setup2TestField
    
    syntax Setup2TestField ::= "IS_TEST" [symbol(), klabel(field_Setup2Test_IS_TEST)]
    
    syntax Setup2TestField ::= "_failed" [symbol(), klabel(field_Setup2Test__failed)]
    
    syntax Setup2TestField ::= "IS_SCRIPT" [symbol(), klabel(field_Setup2Test_IS_SCRIPT)]
    
    syntax Setup2TestField ::= "stdstore" [symbol(), klabel(field_Setup2Test_stdstore)]
    
    syntax Setup2TestField ::= "a" [symbol(), klabel(field_Setup2Test_a)]
    
    syntax Setup2TestField ::= "b" [symbol(), klabel(field_Setup2Test_b)]
    
    syntax Setup2TestField ::= "c" [symbol(), klabel(field_Setup2Test_c)]
    
    rule  ( #loc ( Setup2Test . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( Setup2Test . _failed ) => 0 )
      
    
    rule  ( #loc ( Setup2Test . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( Setup2Test . stdstore ) => 1 )
      
    
    rule  ( #loc ( Setup2Test . a ) => 8 )
      
    
    rule  ( #loc ( Setup2Test . b ) => 9 )
      
    
    rule  ( #loc ( Setup2Test . c ) => 10 )
      
    
    syntax Bytes ::= Setup2TestContract "." Setup2TestMethod [function(), symbol(), klabel(method_Setup2Test)]
    
    syntax Setup2TestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_Setup2Test_IS_SCRIPT)]
    
    syntax Setup2TestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_Setup2Test_IS_TEST)]
    
    syntax Setup2TestMethod ::= "failed" "(" ")" [symbol(), klabel(method_Setup2Test_failed)]
    
    syntax Setup2TestMethod ::= "setUp" "(" ")" [symbol(), klabel(method_Setup2Test_setUp)]
    
    syntax Setup2TestMethod ::= "testFail_setup" "(" ")" [symbol(), klabel(method_Setup2Test_testFail_setup)]
    
    syntax Setup2TestMethod ::= "test_setup" "(" ")" [symbol(), klabel(method_Setup2Test_test_setup)]
    
    syntax Setup2TestMethod ::= "vm" "(" ")" [symbol(), klabel(method_Setup2Test_vm)]
    
    rule  ( Setup2Test . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( Setup2Test . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( Setup2Test . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( Setup2Test . setUp ( ) => #abiCallData ( "setUp" , .TypedArgs ) )
      
    
    rule  ( Setup2Test . testFail_setup ( ) => #abiCallData ( "testFail_setup" , .TypedArgs ) )
      
    
    rule  ( Setup2Test . test_setup ( ) => #abiCallData ( "test_setup" , .TypedArgs ) )
      
    
    rule  ( Setup2Test . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "setUp" ) => 177362148 )
      
    
    rule  ( selector ( "testFail_setup" ) => 3501410022 )
      
    
    rule  ( selector ( "test_setup" ) => 2001288179 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module SETUPTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= SetUpTestContract
    
    syntax SetUpTestContract ::= "SetUpTest" [symbol(), klabel(contract_SetUpTest)]
    
      
    
    syntax Field ::= SetUpTestField
    
    syntax SetUpTestField ::= "IS_TEST" [symbol(), klabel(field_SetUpTest_IS_TEST)]
    
    syntax SetUpTestField ::= "_failed" [symbol(), klabel(field_SetUpTest__failed)]
    
    syntax SetUpTestField ::= "IS_SCRIPT" [symbol(), klabel(field_SetUpTest_IS_SCRIPT)]
    
    syntax SetUpTestField ::= "stdstore" [symbol(), klabel(field_SetUpTest_stdstore)]
    
    syntax SetUpTestField ::= "counter" [symbol(), klabel(field_SetUpTest_counter)]
    
    rule  ( #loc ( SetUpTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( SetUpTest . _failed ) => 0 )
      
    
    rule  ( #loc ( SetUpTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( SetUpTest . stdstore ) => 1 )
      
    
    rule  ( #loc ( SetUpTest . counter ) => 8 )
      
    
    syntax Bytes ::= SetUpTestContract "." SetUpTestMethod [function(), symbol(), klabel(method_SetUpTest)]
    
    syntax SetUpTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_SetUpTest_IS_SCRIPT)]
    
    syntax SetUpTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_SetUpTest_IS_TEST)]
    
    syntax SetUpTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_SetUpTest_failed)]
    
    syntax SetUpTestMethod ::= "setUp" "(" ")" [symbol(), klabel(method_SetUpTest_setUp)]
    
    syntax SetUpTestMethod ::= "testSetUpCalled" "(" ")" [symbol(), klabel(method_SetUpTest_testSetUpCalled)]
    
    syntax SetUpTestMethod ::= "testSetUpCalledSymbolic" "(" Int ")" [symbol(), klabel(method_SetUpTest_testSetUpCalledSymbolic)]
    
    syntax SetUpTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_SetUpTest_vm)]
    
    rule  ( SetUpTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( SetUpTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( SetUpTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( SetUpTest . setUp ( ) => #abiCallData ( "setUp" , .TypedArgs ) )
      
    
    rule  ( SetUpTest . testSetUpCalled ( ) => #abiCallData ( "testSetUpCalled" , .TypedArgs ) )
      
    
    rule  ( SetUpTest . testSetUpCalledSymbolic ( V0_x ) => #abiCallData ( "testSetUpCalledSymbolic" , #uint256 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( SetUpTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "setUp" ) => 177362148 )
      
    
    rule  ( selector ( "testSetUpCalled" ) => 3967804529 )
      
    
    rule  ( selector ( "testSetUpCalledSymbolic" ) => 3332480466 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module SIGNTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= SignTestContract
    
    syntax SignTestContract ::= "SignTest" [symbol(), klabel(contract_SignTest)]
    
      
    
    syntax Field ::= SignTestField
    
    syntax SignTestField ::= "IS_TEST" [symbol(), klabel(field_SignTest_IS_TEST)]
    
    syntax SignTestField ::= "_failed" [symbol(), klabel(field_SignTest__failed)]
    
    syntax SignTestField ::= "IS_SCRIPT" [symbol(), klabel(field_SignTest_IS_SCRIPT)]
    
    syntax SignTestField ::= "stdstore" [symbol(), klabel(field_SignTest_stdstore)]
    
    rule  ( #loc ( SignTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( SignTest . _failed ) => 0 )
      
    
    rule  ( #loc ( SignTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( SignTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= SignTestContract "." SignTestMethod [function(), symbol(), klabel(method_SignTest)]
    
    syntax SignTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_SignTest_IS_SCRIPT)]
    
    syntax SignTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_SignTest_IS_TEST)]
    
    syntax SignTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_SignTest_failed)]
    
    syntax SignTestMethod ::= "testSign" "(" ")" [symbol(), klabel(method_SignTest_testSign)]
    
    syntax SignTestMethod ::= "testSign_symbolic" "(" Int ")" [symbol(), klabel(method_SignTest_testSign_symbolic)]
    
    syntax SignTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_SignTest_vm)]
    
    rule  ( SignTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( SignTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( SignTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( SignTest . testSign ( ) => #abiCallData ( "testSign" , .TypedArgs ) )
      
    
    rule  ( SignTest . testSign_symbolic ( V0_pk ) => #abiCallData ( "testSign_symbolic" , #uint256 ( V0_pk ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_pk )
      
    
    rule  ( SignTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testSign" ) => 3985576159 )
      
    
    rule  ( selector ( "testSign_symbolic" ) => 2942025997 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module ASSERTTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= AssertTestContract
    
    syntax AssertTestContract ::= "AssertTest" [symbol(), klabel(contract_AssertTest)]
    
      
    
    syntax Field ::= AssertTestField
    
    syntax AssertTestField ::= "IS_TEST" [symbol(), klabel(field_AssertTest_IS_TEST)]
    
    syntax AssertTestField ::= "_failed" [symbol(), klabel(field_AssertTest__failed)]
    
    syntax AssertTestField ::= "IS_SCRIPT" [symbol(), klabel(field_AssertTest_IS_SCRIPT)]
    
    syntax AssertTestField ::= "stdstore" [symbol(), klabel(field_AssertTest_stdstore)]
    
    syntax AssertTestField ::= "y" [symbol(), klabel(field_AssertTest_y)]
    
    rule  ( #loc ( AssertTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( AssertTest . _failed ) => 0 )
      
    
    rule  ( #loc ( AssertTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( AssertTest . stdstore ) => 1 )
      
    
    rule  ( #loc ( AssertTest . y ) => 8 )
      
    
    syntax Bytes ::= AssertTestContract "." AssertTestMethod [function(), symbol(), klabel(method_AssertTest)]
    
    syntax AssertTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_AssertTest_IS_SCRIPT)]
    
    syntax AssertTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_AssertTest_IS_TEST)]
    
    syntax AssertTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_AssertTest_failed)]
    
    syntax AssertTestMethod ::= "testFail_assert_false" "(" ")" [symbol(), klabel(method_AssertTest_testFail_assert_false)]
    
    syntax AssertTestMethod ::= "testFail_assert_true" "(" ")" [symbol(), klabel(method_AssertTest_testFail_assert_true)]
    
    syntax AssertTestMethod ::= "testFail_expect_revert" "(" ")" [symbol(), klabel(method_AssertTest_testFail_expect_revert)]
    
    syntax AssertTestMethod ::= "test_assert_false" "(" ")" [symbol(), klabel(method_AssertTest_test_assert_false)]
    
    syntax AssertTestMethod ::= "test_assert_true" "(" ")" [symbol(), klabel(method_AssertTest_test_assert_true)]
    
    syntax AssertTestMethod ::= "test_assert_true_branch" "(" Int ")" [symbol(), klabel(method_AssertTest_test_assert_true_branch)]
    
    syntax AssertTestMethod ::= "test_revert_branch" "(" Int "," Int ")" [symbol(), klabel(method_AssertTest_test_revert_branch)]
    
    syntax AssertTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_AssertTest_vm)]
    
    rule  ( AssertTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( AssertTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( AssertTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( AssertTest . testFail_assert_false ( ) => #abiCallData ( "testFail_assert_false" , .TypedArgs ) )
      
    
    rule  ( AssertTest . testFail_assert_true ( ) => #abiCallData ( "testFail_assert_true" , .TypedArgs ) )
      
    
    rule  ( AssertTest . testFail_expect_revert ( ) => #abiCallData ( "testFail_expect_revert" , .TypedArgs ) )
      
    
    rule  ( AssertTest . test_assert_false ( ) => #abiCallData ( "test_assert_false" , .TypedArgs ) )
      
    
    rule  ( AssertTest . test_assert_true ( ) => #abiCallData ( "test_assert_true" , .TypedArgs ) )
      
    
    rule  ( AssertTest . test_assert_true_branch ( V0_x ) => #abiCallData ( "test_assert_true_branch" , #uint256 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( AssertTest . test_revert_branch ( V0_x , V1_y ) => #abiCallData ( "test_revert_branch" , #uint256 ( V0_x ) , #uint256 ( V1_y ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_x )
       andBool ( #rangeUInt ( 256 , V1_y )
               ))
      
    
    rule  ( AssertTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testFail_assert_false" ) => 2057948334 )
      
    
    rule  ( selector ( "testFail_assert_true" ) => 409427266 )
      
    
    rule  ( selector ( "testFail_expect_revert" ) => 709747105 )
      
    
    rule  ( selector ( "test_assert_false" ) => 1574882301 )
      
    
    rule  ( selector ( "test_assert_true" ) => 906863826 )
      
    
    rule  ( selector ( "test_assert_true_branch" ) => 3267411143 )
      
    
    rule  ( selector ( "test_revert_branch" ) => 2349784459 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module SNAPSHOTTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= SnapshotTestContract
    
    syntax SnapshotTestContract ::= "SnapshotTest" [symbol(), klabel(contract_SnapshotTest)]
    
      
    
    syntax Field ::= SnapshotTestField
    
    syntax SnapshotTestField ::= "IS_TEST" [symbol(), klabel(field_SnapshotTest_IS_TEST)]
    
    syntax SnapshotTestField ::= "_failed" [symbol(), klabel(field_SnapshotTest__failed)]
    
    syntax SnapshotTestField ::= "IS_SCRIPT" [symbol(), klabel(field_SnapshotTest_IS_SCRIPT)]
    
    syntax SnapshotTestField ::= "stdstore" [symbol(), klabel(field_SnapshotTest_stdstore)]
    
    syntax SnapshotTestField ::= "store" [symbol(), klabel(field_SnapshotTest_store)]
    
    rule  ( #loc ( SnapshotTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( SnapshotTest . _failed ) => 0 )
      
    
    rule  ( #loc ( SnapshotTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( SnapshotTest . stdstore ) => 1 )
      
    
    rule  ( #loc ( SnapshotTest . store ) => 8 )
      
    
    syntax Bytes ::= SnapshotTestContract "." SnapshotTestMethod [function(), symbol(), klabel(method_SnapshotTest)]
    
    syntax SnapshotTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_SnapshotTest_IS_SCRIPT)]
    
    syntax SnapshotTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_SnapshotTest_IS_TEST)]
    
    syntax SnapshotTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_SnapshotTest_failed)]
    
    syntax SnapshotTestMethod ::= "setUp" "(" ")" [symbol(), klabel(method_SnapshotTest_setUp)]
    
    syntax SnapshotTestMethod ::= "testSnapshot" "(" ")" [symbol(), klabel(method_SnapshotTest_testSnapshot)]
    
    syntax SnapshotTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_SnapshotTest_vm)]
    
    rule  ( SnapshotTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( SnapshotTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( SnapshotTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( SnapshotTest . setUp ( ) => #abiCallData ( "setUp" , .TypedArgs ) )
      
    
    rule  ( SnapshotTest . testSnapshot ( ) => #abiCallData ( "testSnapshot" , .TypedArgs ) )
      
    
    rule  ( SnapshotTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "setUp" ) => 177362148 )
      
    
    rule  ( selector ( "testSnapshot" ) => 3204135818 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module STORE-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= StoreContract
    
    syntax StoreContract ::= "Store" [symbol(), klabel(contract_Store)]
    
      
    
    syntax Field ::= StoreField
    
    syntax StoreField ::= "testNumber" [symbol(), klabel(field_Store_testNumber)]
    
    rule  ( #loc ( Store . testNumber ) => 0 )
      

endmodule

module STORETEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= StoreTestContract
    
    syntax StoreTestContract ::= "StoreTest" [symbol(), klabel(contract_StoreTest)]
    
      
    
    syntax Field ::= StoreTestField
    
    syntax StoreTestField ::= "IS_TEST" [symbol(), klabel(field_StoreTest_IS_TEST)]
    
    syntax StoreTestField ::= "_failed" [symbol(), klabel(field_StoreTest__failed)]
    
    syntax StoreTestField ::= "IS_SCRIPT" [symbol(), klabel(field_StoreTest_IS_SCRIPT)]
    
    syntax StoreTestField ::= "stdstore" [symbol(), klabel(field_StoreTest_stdstore)]
    
    rule  ( #loc ( StoreTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( StoreTest . _failed ) => 0 )
      
    
    rule  ( #loc ( StoreTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( StoreTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= StoreTestContract "." StoreTestMethod [function(), symbol(), klabel(method_StoreTest)]
    
    syntax StoreTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_StoreTest_IS_SCRIPT)]
    
    syntax StoreTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_StoreTest_IS_TEST)]
    
    syntax StoreTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_StoreTest_failed)]
    
    syntax StoreTestMethod ::= "testAccesses" "(" ")" [symbol(), klabel(method_StoreTest_testAccesses)]
    
    syntax StoreTestMethod ::= "testGasLoadColdVM" "(" ")" [symbol(), klabel(method_StoreTest_testGasLoadColdVM)]
    
    syntax StoreTestMethod ::= "testGasLoadWarmUp" "(" ")" [symbol(), klabel(method_StoreTest_testGasLoadWarmUp)]
    
    syntax StoreTestMethod ::= "testGasLoadWarmVM" "(" ")" [symbol(), klabel(method_StoreTest_testGasLoadWarmVM)]
    
    syntax StoreTestMethod ::= "testGasStoreColdVM" "(" ")" [symbol(), klabel(method_StoreTest_testGasStoreColdVM)]
    
    syntax StoreTestMethod ::= "testGasStoreWarmUp" "(" ")" [symbol(), klabel(method_StoreTest_testGasStoreWarmUp)]
    
    syntax StoreTestMethod ::= "testGasStoreWarmVM" "(" ")" [symbol(), klabel(method_StoreTest_testGasStoreWarmVM)]
    
    syntax StoreTestMethod ::= "testLoadNonExistent" "(" ")" [symbol(), klabel(method_StoreTest_testLoadNonExistent)]
    
    syntax StoreTestMethod ::= "testStoreLoad" "(" ")" [symbol(), klabel(method_StoreTest_testStoreLoad)]
    
    syntax StoreTestMethod ::= "testStoreLoadNonExistent" "(" ")" [symbol(), klabel(method_StoreTest_testStoreLoadNonExistent)]
    
    syntax StoreTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_StoreTest_vm)]
    
    rule  ( StoreTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( StoreTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( StoreTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( StoreTest . testAccesses ( ) => #abiCallData ( "testAccesses" , .TypedArgs ) )
      
    
    rule  ( StoreTest . testGasLoadColdVM ( ) => #abiCallData ( "testGasLoadColdVM" , .TypedArgs ) )
      
    
    rule  ( StoreTest . testGasLoadWarmUp ( ) => #abiCallData ( "testGasLoadWarmUp" , .TypedArgs ) )
      
    
    rule  ( StoreTest . testGasLoadWarmVM ( ) => #abiCallData ( "testGasLoadWarmVM" , .TypedArgs ) )
      
    
    rule  ( StoreTest . testGasStoreColdVM ( ) => #abiCallData ( "testGasStoreColdVM" , .TypedArgs ) )
      
    
    rule  ( StoreTest . testGasStoreWarmUp ( ) => #abiCallData ( "testGasStoreWarmUp" , .TypedArgs ) )
      
    
    rule  ( StoreTest . testGasStoreWarmVM ( ) => #abiCallData ( "testGasStoreWarmVM" , .TypedArgs ) )
      
    
    rule  ( StoreTest . testLoadNonExistent ( ) => #abiCallData ( "testLoadNonExistent" , .TypedArgs ) )
      
    
    rule  ( StoreTest . testStoreLoad ( ) => #abiCallData ( "testStoreLoad" , .TypedArgs ) )
      
    
    rule  ( StoreTest . testStoreLoadNonExistent ( ) => #abiCallData ( "testStoreLoadNonExistent" , .TypedArgs ) )
      
    
    rule  ( StoreTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testAccesses" ) => 159648693 )
      
    
    rule  ( selector ( "testGasLoadColdVM" ) => 3801282741 )
      
    
    rule  ( selector ( "testGasLoadWarmUp" ) => 604011046 )
      
    
    rule  ( selector ( "testGasLoadWarmVM" ) => 2607902342 )
      
    
    rule  ( selector ( "testGasStoreColdVM" ) => 2309593716 )
      
    
    rule  ( selector ( "testGasStoreWarmUp" ) => 1546465326 )
      
    
    rule  ( selector ( "testGasStoreWarmVM" ) => 100073271 )
      
    
    rule  ( selector ( "testLoadNonExistent" ) => 2275977243 )
      
    
    rule  ( selector ( "testStoreLoad" ) => 1208516723 )
      
    
    rule  ( selector ( "testStoreLoadNonExistent" ) => 3912017339 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module SYMBOLICSTORAGETEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= SymbolicStorageTestContract
    
    syntax SymbolicStorageTestContract ::= "SymbolicStorageTest" [symbol(), klabel(contract_SymbolicStorageTest)]
    
      
    
    syntax Field ::= SymbolicStorageTestField
    
    syntax SymbolicStorageTestField ::= "IS_TEST" [symbol(), klabel(field_SymbolicStorageTest_IS_TEST)]
    
    syntax SymbolicStorageTestField ::= "_failed" [symbol(), klabel(field_SymbolicStorageTest__failed)]
    
    syntax SymbolicStorageTestField ::= "IS_SCRIPT" [symbol(), klabel(field_SymbolicStorageTest_IS_SCRIPT)]
    
    syntax SymbolicStorageTestField ::= "stdstore" [symbol(), klabel(field_SymbolicStorageTest_stdstore)]
    
    rule  ( #loc ( SymbolicStorageTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( SymbolicStorageTest . _failed ) => 0 )
      
    
    rule  ( #loc ( SymbolicStorageTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( SymbolicStorageTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= SymbolicStorageTestContract "." SymbolicStorageTestMethod [function(), symbol(), klabel(method_SymbolicStorageTest)]
    
    syntax SymbolicStorageTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_SymbolicStorageTest_IS_SCRIPT)]
    
    syntax SymbolicStorageTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_SymbolicStorageTest_IS_TEST)]
    
    syntax SymbolicStorageTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_SymbolicStorageTest_failed)]
    
    syntax SymbolicStorageTestMethod ::= "kevm" "(" ")" [symbol(), klabel(method_SymbolicStorageTest_kevm)]
    
    syntax SymbolicStorageTestMethod ::= "testEmptyInitialStorage" "(" Int ")" [symbol(), klabel(method_SymbolicStorageTest_testEmptyInitialStorage)]
    
    syntax SymbolicStorageTestMethod ::= "testFail_SymbolicStorage" "(" Int ")" [symbol(), klabel(method_SymbolicStorageTest_testFail_SymbolicStorage)]
    
    syntax SymbolicStorageTestMethod ::= "testFail_SymbolicStorage1" "(" Int ")" [symbol(), klabel(method_SymbolicStorageTest_testFail_SymbolicStorage1)]
    
    syntax SymbolicStorageTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_SymbolicStorageTest_vm)]
    
    rule  ( SymbolicStorageTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( SymbolicStorageTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( SymbolicStorageTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( SymbolicStorageTest . kevm ( ) => #abiCallData ( "kevm" , .TypedArgs ) )
      
    
    rule  ( SymbolicStorageTest . testEmptyInitialStorage ( V0_slot ) => #abiCallData ( "testEmptyInitialStorage" , #uint256 ( V0_slot ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_slot )
      
    
    rule  ( SymbolicStorageTest . testFail_SymbolicStorage ( V0_slot ) => #abiCallData ( "testFail_SymbolicStorage" , #uint256 ( V0_slot ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_slot )
      
    
    rule  ( SymbolicStorageTest . testFail_SymbolicStorage1 ( V0_slot ) => #abiCallData ( "testFail_SymbolicStorage1" , #uint256 ( V0_slot ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_slot )
      
    
    rule  ( SymbolicStorageTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "kevm" ) => 3601001590 )
      
    
    rule  ( selector ( "testEmptyInitialStorage" ) => 2517793094 )
      
    
    rule  ( selector ( "testFail_SymbolicStorage" ) => 821477045 )
      
    
    rule  ( selector ( "testFail_SymbolicStorage1" ) => 2899744320 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module SYMBOLICSTORE-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= SymbolicStoreContract
    
    syntax SymbolicStoreContract ::= "SymbolicStore" [symbol(), klabel(contract_SymbolicStore)]
    
      
    
    syntax Field ::= SymbolicStoreField
    
    syntax SymbolicStoreField ::= "testNumber" [symbol(), klabel(field_SymbolicStore_testNumber)]
    
    rule  ( #loc ( SymbolicStore . testNumber ) => 0 )
      

endmodule

module TEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= TestContract
    
    syntax TestContract ::= "Test" [symbol(), klabel(contract_Test)]
    
      
    
    syntax Field ::= TestField
    
    syntax TestField ::= "IS_TEST" [symbol(), klabel(field_Test_IS_TEST)]
    
    syntax TestField ::= "_failed" [symbol(), klabel(field_Test__failed)]
    
    syntax TestField ::= "IS_SCRIPT" [symbol(), klabel(field_Test_IS_SCRIPT)]
    
    syntax TestField ::= "stdstore" [symbol(), klabel(field_Test_stdstore)]
    
    rule  ( #loc ( Test . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( Test . _failed ) => 0 )
      
    
    rule  ( #loc ( Test . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( Test . stdstore ) => 1 )
      
    
    syntax Bytes ::= TestContract "." TestMethod [function(), symbol(), klabel(method_Test)]
    
    syntax TestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_Test_IS_SCRIPT)]
    
    syntax TestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_Test_IS_TEST)]
    
    syntax TestMethod ::= "failed" "(" ")" [symbol(), klabel(method_Test_failed)]
    
    syntax TestMethod ::= "vm" "(" ")" [symbol(), klabel(method_Test_vm)]
    
    rule  ( Test . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( Test . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( Test . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( Test . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module STDERROR-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= StdErrorContract
    
    syntax StdErrorContract ::= "stdError" [symbol(), klabel(contract_stdError)]
    
      
    
    syntax Bytes ::= StdErrorContract "." StdErrorMethod [function(), symbol(), klabel(method_stdError)]
    
    syntax StdErrorMethod ::= "arithmeticError" "(" ")" [symbol(), klabel(method_stdError_arithmeticError)]
    
    syntax StdErrorMethod ::= "assertionError" "(" ")" [symbol(), klabel(method_stdError_assertionError)]
    
    syntax StdErrorMethod ::= "divisionError" "(" ")" [symbol(), klabel(method_stdError_divisionError)]
    
    syntax StdErrorMethod ::= "encodeStorageError" "(" ")" [symbol(), klabel(method_stdError_encodeStorageError)]
    
    syntax StdErrorMethod ::= "enumConversionError" "(" ")" [symbol(), klabel(method_stdError_enumConversionError)]
    
    syntax StdErrorMethod ::= "indexOOBError" "(" ")" [symbol(), klabel(method_stdError_indexOOBError)]
    
    syntax StdErrorMethod ::= "lowLevelError" "(" ")" [symbol(), klabel(method_stdError_lowLevelError)]
    
    syntax StdErrorMethod ::= "memOverflowError" "(" ")" [symbol(), klabel(method_stdError_memOverflowError)]
    
    syntax StdErrorMethod ::= "popError" "(" ")" [symbol(), klabel(method_stdError_popError)]
    
    syntax StdErrorMethod ::= "zeroVarError" "(" ")" [symbol(), klabel(method_stdError_zeroVarError)]
    
    rule  ( stdError . arithmeticError ( ) => #abiCallData ( "arithmeticError" , .TypedArgs ) )
      
    
    rule  ( stdError . assertionError ( ) => #abiCallData ( "assertionError" , .TypedArgs ) )
      
    
    rule  ( stdError . divisionError ( ) => #abiCallData ( "divisionError" , .TypedArgs ) )
      
    
    rule  ( stdError . encodeStorageError ( ) => #abiCallData ( "encodeStorageError" , .TypedArgs ) )
      
    
    rule  ( stdError . enumConversionError ( ) => #abiCallData ( "enumConversionError" , .TypedArgs ) )
      
    
    rule  ( stdError . indexOOBError ( ) => #abiCallData ( "indexOOBError" , .TypedArgs ) )
      
    
    rule  ( stdError . lowLevelError ( ) => #abiCallData ( "lowLevelError" , .TypedArgs ) )
      
    
    rule  ( stdError . memOverflowError ( ) => #abiCallData ( "memOverflowError" , .TypedArgs ) )
      
    
    rule  ( stdError . popError ( ) => #abiCallData ( "popError" , .TypedArgs ) )
      
    
    rule  ( stdError . zeroVarError ( ) => #abiCallData ( "zeroVarError" , .TypedArgs ) )
      
    
    rule  ( selector ( "arithmeticError" ) => 2308253967 )
      
    
    rule  ( selector ( "assertionError" ) => 271788407 )
      
    
    rule  ( selector ( "divisionError" ) => 4202187332 )
      
    
    rule  ( selector ( "encodeStorageError" ) => 3512788190 )
      
    
    rule  ( selector ( "enumConversionError" ) => 501503328 )
      
    
    rule  ( selector ( "indexOOBError" ) => 99517970 )
      
    
    rule  ( selector ( "lowLevelError" ) => 2889716422 )
      
    
    rule  ( selector ( "memOverflowError" ) => 2557239144 )
      
    
    rule  ( selector ( "popError" ) => 2989344077 )
      
    
    rule  ( selector ( "zeroVarError" ) => 3061221850 )
      

endmodule

module STDMATH-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= StdMathContract
    
    syntax StdMathContract ::= "stdMath" [symbol(), klabel(contract_stdMath)]
    
      

endmodule

module STDSTORAGE-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= StdStorageContract
    
    syntax StdStorageContract ::= "stdStorage" [symbol(), klabel(contract_stdStorage)]
    
      
    
    syntax Bytes ::= StdStorageContract "." StdStorageMethod [function(), symbol(), klabel(method_stdStorage)]
    
    syntax StdStorageMethod ::= "bytesToBytes32" "(" Bytes "," Int ")" [symbol(), klabel(method_stdStorage_bytesToBytes32)]
    
    rule  ( stdStorage . bytesToBytes32 ( V0_b , V1_offset ) => #abiCallData ( "bytesToBytes32" , #bytes ( V0_b ) , #uint256 ( V1_offset ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 128 , lengthBytes ( V0_b ) )
       andBool ( #rangeUInt ( 256 , V1_offset )
               ))
      
    
    rule  ( selector ( "bytesToBytes32" ) => 1398294841 )
      

endmodule

module TESTNUMBER-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= TestNumberContract
    
    syntax TestNumberContract ::= "TestNumber" [symbol(), klabel(contract_TestNumber)]
    
      
    
    syntax Field ::= TestNumberField
    
    syntax TestNumberField ::= "IS_TEST" [symbol(), klabel(field_TestNumber_IS_TEST)]
    
    syntax TestNumberField ::= "_failed" [symbol(), klabel(field_TestNumber__failed)]
    
    syntax TestNumberField ::= "testNumber" [symbol(), klabel(field_TestNumber_testNumber)]
    
    rule  ( #loc ( TestNumber . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( TestNumber . _failed ) => 0 )
      
    
    rule  ( #loc ( TestNumber . testNumber ) => 1 )
      
    
    syntax Bytes ::= TestNumberContract "." TestNumberMethod [function(), symbol(), klabel(method_TestNumber)]
    
    syntax TestNumberMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_TestNumber_IS_TEST)]
    
    syntax TestNumberMethod ::= "failed" "(" ")" [symbol(), klabel(method_TestNumber_failed)]
    
    syntax TestNumberMethod ::= "t" "(" Int ")" [symbol(), klabel(method_TestNumber_t)]
    
    syntax TestNumberMethod ::= "testNumber" "(" ")" [symbol(), klabel(method_TestNumber_testNumber)]
    
    rule  ( TestNumber . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( TestNumber . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( TestNumber . t ( V0_a ) => #abiCallData ( "t" , #uint256 ( V0_a ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_a )
      
    
    rule  ( TestNumber . testNumber ( ) => #abiCallData ( "testNumber" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "t" ) => 2950864753 )
      
    
    rule  ( selector ( "testNumber" ) => 219771635 )
      

endmodule

module TOSTRINGTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ToStringTestContract
    
    syntax ToStringTestContract ::= "ToStringTest" [symbol(), klabel(contract_ToStringTest)]
    
      
    
    syntax Field ::= ToStringTestField
    
    syntax ToStringTestField ::= "IS_TEST" [symbol(), klabel(field_ToStringTest_IS_TEST)]
    
    syntax ToStringTestField ::= "_failed" [symbol(), klabel(field_ToStringTest__failed)]
    
    syntax ToStringTestField ::= "IS_SCRIPT" [symbol(), klabel(field_ToStringTest_IS_SCRIPT)]
    
    syntax ToStringTestField ::= "stdstore" [symbol(), klabel(field_ToStringTest_stdstore)]
    
    rule  ( #loc ( ToStringTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( ToStringTest . _failed ) => 0 )
      
    
    rule  ( #loc ( ToStringTest . IS_SCRIPT ) => 0 )
      
    
    rule  ( #loc ( ToStringTest . stdstore ) => 1 )
      
    
    syntax Bytes ::= ToStringTestContract "." ToStringTestMethod [function(), symbol(), klabel(method_ToStringTest)]
    
    syntax ToStringTestMethod ::= "IS_SCRIPT" "(" ")" [symbol(), klabel(method_ToStringTest_IS_SCRIPT)]
    
    syntax ToStringTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_ToStringTest_IS_TEST)]
    
    syntax ToStringTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_ToStringTest_failed)]
    
    syntax ToStringTestMethod ::= "testAddressToString" "(" ")" [symbol(), klabel(method_ToStringTest_testAddressToString)]
    
    syntax ToStringTestMethod ::= "testBoolToString" "(" ")" [symbol(), klabel(method_ToStringTest_testBoolToString)]
    
    syntax ToStringTestMethod ::= "testBytes32ToString" "(" ")" [symbol(), klabel(method_ToStringTest_testBytes32ToString)]
    
    syntax ToStringTestMethod ::= "testBytesToString" "(" ")" [symbol(), klabel(method_ToStringTest_testBytesToString)]
    
    syntax ToStringTestMethod ::= "testIntToString" "(" ")" [symbol(), klabel(method_ToStringTest_testIntToString)]
    
    syntax ToStringTestMethod ::= "testUint256ToString" "(" ")" [symbol(), klabel(method_ToStringTest_testUint256ToString)]
    
    syntax ToStringTestMethod ::= "vm" "(" ")" [symbol(), klabel(method_ToStringTest_vm)]
    
    rule  ( ToStringTest . IS_SCRIPT ( ) => #abiCallData ( "IS_SCRIPT" , .TypedArgs ) )
      
    
    rule  ( ToStringTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( ToStringTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( ToStringTest . testAddressToString ( ) => #abiCallData ( "testAddressToString" , .TypedArgs ) )
      
    
    rule  ( ToStringTest . testBoolToString ( ) => #abiCallData ( "testBoolToString" , .TypedArgs ) )
      
    
    rule  ( ToStringTest . testBytes32ToString ( ) => #abiCallData ( "testBytes32ToString" , .TypedArgs ) )
      
    
    rule  ( ToStringTest . testBytesToString ( ) => #abiCallData ( "testBytesToString" , .TypedArgs ) )
      
    
    rule  ( ToStringTest . testIntToString ( ) => #abiCallData ( "testIntToString" , .TypedArgs ) )
      
    
    rule  ( ToStringTest . testUint256ToString ( ) => #abiCallData ( "testUint256ToString" , .TypedArgs ) )
      
    
    rule  ( ToStringTest . vm ( ) => #abiCallData ( "vm" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_SCRIPT" ) => 4174167879 )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      
    
    rule  ( selector ( "testAddressToString" ) => 808104093 )
      
    
    rule  ( selector ( "testBoolToString" ) => 1097632899 )
      
    
    rule  ( selector ( "testBytes32ToString" ) => 204853932 )
      
    
    rule  ( selector ( "testBytesToString" ) => 1397983993 )
      
    
    rule  ( selector ( "testIntToString" ) => 4039840763 )
      
    
    rule  ( selector ( "testUint256ToString" ) => 98980210 )
      
    
    rule  ( selector ( "vm" ) => 980845667 )
      

endmodule

module TOKEN-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= TokenContract
    
    syntax TokenContract ::= "Token" [symbol(), klabel(contract_Token)]
    
      
    
    syntax Field ::= TokenField
    
    syntax TokenField ::= "x" [symbol(), klabel(field_Token_x)]
    
    syntax TokenField ::= "balances" [symbol(), klabel(field_Token_balances)]
    
    syntax TokenField ::= "allowances" [symbol(), klabel(field_Token_allowances)]
    
    syntax TokenField ::= "name" [symbol(), klabel(field_Token_name)]
    
    syntax TokenField ::= "y" [symbol(), klabel(field_Token_y)]
    
    syntax TokenField ::= "z" [symbol(), klabel(field_Token_z)]
    
    syntax TokenField ::= "a" [symbol(), klabel(field_Token_a)]
    
    syntax TokenField ::= "foos" [symbol(), klabel(field_Token_foos)]
    
    rule  ( #loc ( Token . x ) => 0 )
      
    
    rule  ( #loc ( Token . balances ) => 1 )
      
    
    rule  ( #loc ( Token . allowances ) => 2 )
      
    
    rule  ( #loc ( Token . name ) => 3 )
      
    
    rule  ( #loc ( Token . y ) => 4 )
      
    
    rule  ( #loc ( Token . z ) => 4 )
      
    
    rule  ( #loc ( Token . a ) => 4 )
      
    
    rule  ( #loc ( Token . foos ) => 5 )
      
    
    syntax Bytes ::= TokenContract "." TokenMethod [function(), symbol(), klabel(method_Token)]
    
    syntax TokenMethod ::= "transfer" "(" Int "," Int ")" [symbol(), klabel(method_Token_transfer)]
    
    rule  ( Token . transfer ( V0_dst , V1_amount ) => #abiCallData ( "transfer" , #address ( V0_dst ) , #uint256 ( V1_amount ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_dst )
       andBool ( #rangeUInt ( 256 , V1_amount )
               ))
      
    
    rule  ( selector ( "transfer" ) => 2835717307 )
      

endmodule

module BYTESTYPETEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= BytesTypeTestContract
    
    syntax BytesTypeTestContract ::= "BytesTypeTest" [symbol(), klabel(contract_BytesTypeTest)]
    
      
    
    syntax Bytes ::= BytesTypeTestContract "." BytesTypeTestMethod [function(), symbol(), klabel(method_BytesTypeTest)]
    
    syntax BytesTypeTestMethod ::= "testFail_bytes32" "(" Int ")" [symbol(), klabel(method_BytesTypeTest_testFail_bytes32)]
    
    syntax BytesTypeTestMethod ::= "testFail_bytes4" "(" Int ")" [symbol(), klabel(method_BytesTypeTest_testFail_bytes4)]
    
    syntax BytesTypeTestMethod ::= "test_bytes32" "(" Int ")" [symbol(), klabel(method_BytesTypeTest_test_bytes32)]
    
    syntax BytesTypeTestMethod ::= "test_bytes32_fail" "(" Int ")" [symbol(), klabel(method_BytesTypeTest_test_bytes32_fail)]
    
    syntax BytesTypeTestMethod ::= "test_bytes4" "(" Int ")" [symbol(), klabel(method_BytesTypeTest_test_bytes4)]
    
    syntax BytesTypeTestMethod ::= "test_bytes4_fail" "(" Int ")" [symbol(), klabel(method_BytesTypeTest_test_bytes4_fail)]
    
    rule  ( BytesTypeTest . testFail_bytes32 ( V0_x ) => #abiCallData ( "testFail_bytes32" , #bytes32 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( BytesTypeTest . testFail_bytes4 ( V0_x ) => #abiCallData ( "testFail_bytes4" , #bytes4 ( V0_x ) , .TypedArgs ) )
       ensures #rangeBytes ( 4 , V0_x )
      
    
    rule  ( BytesTypeTest . test_bytes32 ( V0_x ) => #abiCallData ( "test_bytes32" , #bytes32 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( BytesTypeTest . test_bytes32_fail ( V0_x ) => #abiCallData ( "test_bytes32_fail" , #bytes32 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( BytesTypeTest . test_bytes4 ( V0_x ) => #abiCallData ( "test_bytes4" , #bytes4 ( V0_x ) , .TypedArgs ) )
       ensures #rangeBytes ( 4 , V0_x )
      
    
    rule  ( BytesTypeTest . test_bytes4_fail ( V0_x ) => #abiCallData ( "test_bytes4_fail" , #bytes4 ( V0_x ) , .TypedArgs ) )
       ensures #rangeBytes ( 4 , V0_x )
      
    
    rule  ( selector ( "testFail_bytes32" ) => 4289330289 )
      
    
    rule  ( selector ( "testFail_bytes4" ) => 3602852570 )
      
    
    rule  ( selector ( "test_bytes32" ) => 3436986189 )
      
    
    rule  ( selector ( "test_bytes32_fail" ) => 392713219 )
      
    
    rule  ( selector ( "test_bytes4" ) => 2814412853 )
      
    
    rule  ( selector ( "test_bytes4_fail" ) => 2510894010 )
      

endmodule

module UINTTYPETEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= UintTypeTestContract
    
    syntax UintTypeTestContract ::= "UintTypeTest" [symbol(), klabel(contract_UintTypeTest)]
    
      
    
    syntax Bytes ::= UintTypeTestContract "." UintTypeTestMethod [function(), symbol(), klabel(method_UintTypeTest)]
    
    syntax UintTypeTestMethod ::= "testFail_uint104" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint104)]
    
    syntax UintTypeTestMethod ::= "testFail_uint112" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint112)]
    
    syntax UintTypeTestMethod ::= "testFail_uint120" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint120)]
    
    syntax UintTypeTestMethod ::= "testFail_uint128" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint128)]
    
    syntax UintTypeTestMethod ::= "testFail_uint136" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint136)]
    
    syntax UintTypeTestMethod ::= "testFail_uint144" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint144)]
    
    syntax UintTypeTestMethod ::= "testFail_uint152" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint152)]
    
    syntax UintTypeTestMethod ::= "testFail_uint16" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint16)]
    
    syntax UintTypeTestMethod ::= "testFail_uint160" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint160)]
    
    syntax UintTypeTestMethod ::= "testFail_uint168" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint168)]
    
    syntax UintTypeTestMethod ::= "testFail_uint176" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint176)]
    
    syntax UintTypeTestMethod ::= "testFail_uint184" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint184)]
    
    syntax UintTypeTestMethod ::= "testFail_uint192" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint192)]
    
    syntax UintTypeTestMethod ::= "testFail_uint200" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint200)]
    
    syntax UintTypeTestMethod ::= "testFail_uint208" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint208)]
    
    syntax UintTypeTestMethod ::= "testFail_uint216" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint216)]
    
    syntax UintTypeTestMethod ::= "testFail_uint224" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint224)]
    
    syntax UintTypeTestMethod ::= "testFail_uint232" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint232)]
    
    syntax UintTypeTestMethod ::= "testFail_uint24" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint24)]
    
    syntax UintTypeTestMethod ::= "testFail_uint240" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint240)]
    
    syntax UintTypeTestMethod ::= "testFail_uint248" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint248)]
    
    syntax UintTypeTestMethod ::= "testFail_uint256" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint256)]
    
    syntax UintTypeTestMethod ::= "testFail_uint32" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint32)]
    
    syntax UintTypeTestMethod ::= "testFail_uint40" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint40)]
    
    syntax UintTypeTestMethod ::= "testFail_uint48" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint48)]
    
    syntax UintTypeTestMethod ::= "testFail_uint56" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint56)]
    
    syntax UintTypeTestMethod ::= "testFail_uint64" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint64)]
    
    syntax UintTypeTestMethod ::= "testFail_uint72" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint72)]
    
    syntax UintTypeTestMethod ::= "testFail_uint8" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint8)]
    
    syntax UintTypeTestMethod ::= "testFail_uint80" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint80)]
    
    syntax UintTypeTestMethod ::= "testFail_uint88" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint88)]
    
    syntax UintTypeTestMethod ::= "testFail_uint96" "(" Int ")" [symbol(), klabel(method_UintTypeTest_testFail_uint96)]
    
    syntax UintTypeTestMethod ::= "test_uint104" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint104)]
    
    syntax UintTypeTestMethod ::= "test_uint104_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint104_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint112" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint112)]
    
    syntax UintTypeTestMethod ::= "test_uint112_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint112_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint120" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint120)]
    
    syntax UintTypeTestMethod ::= "test_uint120_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint120_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint128" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint128)]
    
    syntax UintTypeTestMethod ::= "test_uint128_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint128_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint136" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint136)]
    
    syntax UintTypeTestMethod ::= "test_uint136_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint136_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint144" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint144)]
    
    syntax UintTypeTestMethod ::= "test_uint144_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint144_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint152" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint152)]
    
    syntax UintTypeTestMethod ::= "test_uint152_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint152_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint16" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint16)]
    
    syntax UintTypeTestMethod ::= "test_uint160" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint160)]
    
    syntax UintTypeTestMethod ::= "test_uint160_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint160_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint168" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint168)]
    
    syntax UintTypeTestMethod ::= "test_uint168_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint168_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint16_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint16_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint176" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint176)]
    
    syntax UintTypeTestMethod ::= "test_uint176_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint176_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint184" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint184)]
    
    syntax UintTypeTestMethod ::= "test_uint184_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint184_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint192" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint192)]
    
    syntax UintTypeTestMethod ::= "test_uint192_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint192_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint200" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint200)]
    
    syntax UintTypeTestMethod ::= "test_uint200_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint200_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint208" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint208)]
    
    syntax UintTypeTestMethod ::= "test_uint208_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint208_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint216" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint216)]
    
    syntax UintTypeTestMethod ::= "test_uint216_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint216_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint224" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint224)]
    
    syntax UintTypeTestMethod ::= "test_uint224_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint224_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint232" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint232)]
    
    syntax UintTypeTestMethod ::= "test_uint232_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint232_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint24" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint24)]
    
    syntax UintTypeTestMethod ::= "test_uint240" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint240)]
    
    syntax UintTypeTestMethod ::= "test_uint240_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint240_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint248" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint248)]
    
    syntax UintTypeTestMethod ::= "test_uint248_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint248_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint24_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint24_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint256" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint256)]
    
    syntax UintTypeTestMethod ::= "test_uint256_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint256_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint32" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint32)]
    
    syntax UintTypeTestMethod ::= "test_uint32_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint32_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint40" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint40)]
    
    syntax UintTypeTestMethod ::= "test_uint40_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint40_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint48" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint48)]
    
    syntax UintTypeTestMethod ::= "test_uint48_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint48_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint56" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint56)]
    
    syntax UintTypeTestMethod ::= "test_uint56_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint56_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint64" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint64)]
    
    syntax UintTypeTestMethod ::= "test_uint64_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint64_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint72" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint72)]
    
    syntax UintTypeTestMethod ::= "test_uint72_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint72_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint8" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint8)]
    
    syntax UintTypeTestMethod ::= "test_uint80" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint80)]
    
    syntax UintTypeTestMethod ::= "test_uint80_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint80_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint88" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint88)]
    
    syntax UintTypeTestMethod ::= "test_uint88_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint88_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint8_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint8_fail)]
    
    syntax UintTypeTestMethod ::= "test_uint96" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint96)]
    
    syntax UintTypeTestMethod ::= "test_uint96_fail" "(" Int ")" [symbol(), klabel(method_UintTypeTest_test_uint96_fail)]
    
    rule  ( UintTypeTest . testFail_uint104 ( V0_x ) => #abiCallData ( "testFail_uint104" , #uint104 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 104 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint112 ( V0_x ) => #abiCallData ( "testFail_uint112" , #uint112 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 112 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint120 ( V0_x ) => #abiCallData ( "testFail_uint120" , #uint120 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 120 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint128 ( V0_x ) => #abiCallData ( "testFail_uint128" , #uint128 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 128 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint136 ( V0_x ) => #abiCallData ( "testFail_uint136" , #uint136 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 136 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint144 ( V0_x ) => #abiCallData ( "testFail_uint144" , #uint144 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 144 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint152 ( V0_x ) => #abiCallData ( "testFail_uint152" , #uint152 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 152 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint16 ( V0_x ) => #abiCallData ( "testFail_uint16" , #uint16 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 16 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint160 ( V0_x ) => #abiCallData ( "testFail_uint160" , #uint160 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 160 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint168 ( V0_x ) => #abiCallData ( "testFail_uint168" , #uint168 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 168 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint176 ( V0_x ) => #abiCallData ( "testFail_uint176" , #uint176 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 176 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint184 ( V0_x ) => #abiCallData ( "testFail_uint184" , #uint184 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 184 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint192 ( V0_x ) => #abiCallData ( "testFail_uint192" , #uint192 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 192 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint200 ( V0_x ) => #abiCallData ( "testFail_uint200" , #uint200 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 200 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint208 ( V0_x ) => #abiCallData ( "testFail_uint208" , #uint208 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 208 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint216 ( V0_x ) => #abiCallData ( "testFail_uint216" , #uint216 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 216 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint224 ( V0_x ) => #abiCallData ( "testFail_uint224" , #uint224 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 224 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint232 ( V0_x ) => #abiCallData ( "testFail_uint232" , #uint232 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 232 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint24 ( V0_x ) => #abiCallData ( "testFail_uint24" , #uint24 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 24 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint240 ( V0_x ) => #abiCallData ( "testFail_uint240" , #uint240 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 240 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint248 ( V0_x ) => #abiCallData ( "testFail_uint248" , #uint248 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 248 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint256 ( V0_x ) => #abiCallData ( "testFail_uint256" , #uint256 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint32 ( V0_x ) => #abiCallData ( "testFail_uint32" , #uint32 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 32 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint40 ( V0_x ) => #abiCallData ( "testFail_uint40" , #uint40 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 40 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint48 ( V0_x ) => #abiCallData ( "testFail_uint48" , #uint48 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 48 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint56 ( V0_x ) => #abiCallData ( "testFail_uint56" , #uint56 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 56 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint64 ( V0_x ) => #abiCallData ( "testFail_uint64" , #uint64 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 64 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint72 ( V0_x ) => #abiCallData ( "testFail_uint72" , #uint72 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 72 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint8 ( V0_x ) => #abiCallData ( "testFail_uint8" , #uint8 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 8 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint80 ( V0_x ) => #abiCallData ( "testFail_uint80" , #uint80 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 80 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint88 ( V0_x ) => #abiCallData ( "testFail_uint88" , #uint88 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 88 , V0_x )
      
    
    rule  ( UintTypeTest . testFail_uint96 ( V0_x ) => #abiCallData ( "testFail_uint96" , #uint96 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 96 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint104 ( V0_x ) => #abiCallData ( "test_uint104" , #uint104 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 104 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint104_fail ( V0_x ) => #abiCallData ( "test_uint104_fail" , #uint104 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 104 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint112 ( V0_x ) => #abiCallData ( "test_uint112" , #uint112 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 112 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint112_fail ( V0_x ) => #abiCallData ( "test_uint112_fail" , #uint112 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 112 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint120 ( V0_x ) => #abiCallData ( "test_uint120" , #uint120 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 120 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint120_fail ( V0_x ) => #abiCallData ( "test_uint120_fail" , #uint120 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 120 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint128 ( V0_x ) => #abiCallData ( "test_uint128" , #uint128 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 128 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint128_fail ( V0_x ) => #abiCallData ( "test_uint128_fail" , #uint128 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 128 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint136 ( V0_x ) => #abiCallData ( "test_uint136" , #uint136 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 136 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint136_fail ( V0_x ) => #abiCallData ( "test_uint136_fail" , #uint136 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 136 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint144 ( V0_x ) => #abiCallData ( "test_uint144" , #uint144 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 144 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint144_fail ( V0_x ) => #abiCallData ( "test_uint144_fail" , #uint144 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 144 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint152 ( V0_x ) => #abiCallData ( "test_uint152" , #uint152 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 152 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint152_fail ( V0_x ) => #abiCallData ( "test_uint152_fail" , #uint152 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 152 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint16 ( V0_x ) => #abiCallData ( "test_uint16" , #uint16 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 16 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint160 ( V0_x ) => #abiCallData ( "test_uint160" , #uint160 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 160 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint160_fail ( V0_x ) => #abiCallData ( "test_uint160_fail" , #uint160 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 160 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint168 ( V0_x ) => #abiCallData ( "test_uint168" , #uint168 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 168 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint168_fail ( V0_x ) => #abiCallData ( "test_uint168_fail" , #uint168 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 168 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint16_fail ( V0_x ) => #abiCallData ( "test_uint16_fail" , #uint16 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 16 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint176 ( V0_x ) => #abiCallData ( "test_uint176" , #uint176 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 176 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint176_fail ( V0_x ) => #abiCallData ( "test_uint176_fail" , #uint176 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 176 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint184 ( V0_x ) => #abiCallData ( "test_uint184" , #uint184 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 184 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint184_fail ( V0_x ) => #abiCallData ( "test_uint184_fail" , #uint184 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 184 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint192 ( V0_x ) => #abiCallData ( "test_uint192" , #uint192 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 192 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint192_fail ( V0_x ) => #abiCallData ( "test_uint192_fail" , #uint192 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 192 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint200 ( V0_x ) => #abiCallData ( "test_uint200" , #uint200 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 200 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint200_fail ( V0_x ) => #abiCallData ( "test_uint200_fail" , #uint200 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 200 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint208 ( V0_x ) => #abiCallData ( "test_uint208" , #uint208 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 208 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint208_fail ( V0_x ) => #abiCallData ( "test_uint208_fail" , #uint208 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 208 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint216 ( V0_x ) => #abiCallData ( "test_uint216" , #uint216 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 216 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint216_fail ( V0_x ) => #abiCallData ( "test_uint216_fail" , #uint216 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 216 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint224 ( V0_x ) => #abiCallData ( "test_uint224" , #uint224 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 224 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint224_fail ( V0_x ) => #abiCallData ( "test_uint224_fail" , #uint224 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 224 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint232 ( V0_x ) => #abiCallData ( "test_uint232" , #uint232 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 232 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint232_fail ( V0_x ) => #abiCallData ( "test_uint232_fail" , #uint232 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 232 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint24 ( V0_x ) => #abiCallData ( "test_uint24" , #uint24 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 24 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint240 ( V0_x ) => #abiCallData ( "test_uint240" , #uint240 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 240 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint240_fail ( V0_x ) => #abiCallData ( "test_uint240_fail" , #uint240 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 240 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint248 ( V0_x ) => #abiCallData ( "test_uint248" , #uint248 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 248 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint248_fail ( V0_x ) => #abiCallData ( "test_uint248_fail" , #uint248 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 248 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint24_fail ( V0_x ) => #abiCallData ( "test_uint24_fail" , #uint24 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 24 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint256 ( V0_x ) => #abiCallData ( "test_uint256" , #uint256 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint256_fail ( V0_x ) => #abiCallData ( "test_uint256_fail" , #uint256 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint32 ( V0_x ) => #abiCallData ( "test_uint32" , #uint32 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 32 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint32_fail ( V0_x ) => #abiCallData ( "test_uint32_fail" , #uint32 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 32 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint40 ( V0_x ) => #abiCallData ( "test_uint40" , #uint40 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 40 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint40_fail ( V0_x ) => #abiCallData ( "test_uint40_fail" , #uint40 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 40 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint48 ( V0_x ) => #abiCallData ( "test_uint48" , #uint48 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 48 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint48_fail ( V0_x ) => #abiCallData ( "test_uint48_fail" , #uint48 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 48 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint56 ( V0_x ) => #abiCallData ( "test_uint56" , #uint56 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 56 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint56_fail ( V0_x ) => #abiCallData ( "test_uint56_fail" , #uint56 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 56 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint64 ( V0_x ) => #abiCallData ( "test_uint64" , #uint64 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 64 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint64_fail ( V0_x ) => #abiCallData ( "test_uint64_fail" , #uint64 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 64 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint72 ( V0_x ) => #abiCallData ( "test_uint72" , #uint72 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 72 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint72_fail ( V0_x ) => #abiCallData ( "test_uint72_fail" , #uint72 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 72 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint8 ( V0_x ) => #abiCallData ( "test_uint8" , #uint8 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 8 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint80 ( V0_x ) => #abiCallData ( "test_uint80" , #uint80 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 80 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint80_fail ( V0_x ) => #abiCallData ( "test_uint80_fail" , #uint80 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 80 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint88 ( V0_x ) => #abiCallData ( "test_uint88" , #uint88 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 88 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint88_fail ( V0_x ) => #abiCallData ( "test_uint88_fail" , #uint88 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 88 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint8_fail ( V0_x ) => #abiCallData ( "test_uint8_fail" , #uint8 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 8 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint96 ( V0_x ) => #abiCallData ( "test_uint96" , #uint96 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 96 , V0_x )
      
    
    rule  ( UintTypeTest . test_uint96_fail ( V0_x ) => #abiCallData ( "test_uint96_fail" , #uint96 ( V0_x ) , .TypedArgs ) )
       ensures #rangeUInt ( 96 , V0_x )
      
    
    rule  ( selector ( "testFail_uint104" ) => 1709154444 )
      
    
    rule  ( selector ( "testFail_uint112" ) => 3541489285 )
      
    
    rule  ( selector ( "testFail_uint120" ) => 3839169067 )
      
    
    rule  ( selector ( "testFail_uint128" ) => 791678561 )
      
    
    rule  ( selector ( "testFail_uint136" ) => 3952257705 )
      
    
    rule  ( selector ( "testFail_uint144" ) => 2439595565 )
      
    
    rule  ( selector ( "testFail_uint152" ) => 1866291148 )
      
    
    rule  ( selector ( "testFail_uint16" ) => 4076431644 )
      
    
    rule  ( selector ( "testFail_uint160" ) => 3214193107 )
      
    
    rule  ( selector ( "testFail_uint168" ) => 2636444862 )
      
    
    rule  ( selector ( "testFail_uint176" ) => 1828125968 )
      
    
    rule  ( selector ( "testFail_uint184" ) => 4099305155 )
      
    
    rule  ( selector ( "testFail_uint192" ) => 2858210891 )
      
    
    rule  ( selector ( "testFail_uint200" ) => 1080270217 )
      
    
    rule  ( selector ( "testFail_uint208" ) => 1831022189 )
      
    
    rule  ( selector ( "testFail_uint216" ) => 2125101602 )
      
    
    rule  ( selector ( "testFail_uint224" ) => 420776541 )
      
    
    rule  ( selector ( "testFail_uint232" ) => 3163478438 )
      
    
    rule  ( selector ( "testFail_uint24" ) => 639153936 )
      
    
    rule  ( selector ( "testFail_uint240" ) => 3089966003 )
      
    
    rule  ( selector ( "testFail_uint248" ) => 3070004620 )
      
    
    rule  ( selector ( "testFail_uint256" ) => 3436494846 )
      
    
    rule  ( selector ( "testFail_uint32" ) => 3218360567 )
      
    
    rule  ( selector ( "testFail_uint40" ) => 347856329 )
      
    
    rule  ( selector ( "testFail_uint48" ) => 4178735009 )
      
    
    rule  ( selector ( "testFail_uint56" ) => 979020984 )
      
    
    rule  ( selector ( "testFail_uint64" ) => 819975489 )
      
    
    rule  ( selector ( "testFail_uint72" ) => 2059244458 )
      
    
    rule  ( selector ( "testFail_uint8" ) => 3679593874 )
      
    
    rule  ( selector ( "testFail_uint80" ) => 4180733980 )
      
    
    rule  ( selector ( "testFail_uint88" ) => 42555031 )
      
    
    rule  ( selector ( "testFail_uint96" ) => 2962957343 )
      
    
    rule  ( selector ( "test_uint104" ) => 2030507202 )
      
    
    rule  ( selector ( "test_uint104_fail" ) => 3289769429 )
      
    
    rule  ( selector ( "test_uint112" ) => 1247465894 )
      
    
    rule  ( selector ( "test_uint112_fail" ) => 198559186 )
      
    
    rule  ( selector ( "test_uint120" ) => 4013273041 )
      
    
    rule  ( selector ( "test_uint120_fail" ) => 4156608892 )
      
    
    rule  ( selector ( "test_uint128" ) => 784802761 )
      
    
    rule  ( selector ( "test_uint128_fail" ) => 3283002391 )
      
    
    rule  ( selector ( "test_uint136" ) => 3590751506 )
      
    
    rule  ( selector ( "test_uint136_fail" ) => 1740049059 )
      
    
    rule  ( selector ( "test_uint144" ) => 1224379367 )
      
    
    rule  ( selector ( "test_uint144_fail" ) => 3911233113 )
      
    
    rule  ( selector ( "test_uint152" ) => 3210764837 )
      
    
    rule  ( selector ( "test_uint152_fail" ) => 2472528383 )
      
    
    rule  ( selector ( "test_uint16" ) => 1262288561 )
      
    
    rule  ( selector ( "test_uint160" ) => 2446641645 )
      
    
    rule  ( selector ( "test_uint160_fail" ) => 1289572651 )
      
    
    rule  ( selector ( "test_uint168" ) => 2789196255 )
      
    
    rule  ( selector ( "test_uint168_fail" ) => 413418206 )
      
    
    rule  ( selector ( "test_uint16_fail" ) => 2736127289 )
      
    
    rule  ( selector ( "test_uint176" ) => 3119759714 )
      
    
    rule  ( selector ( "test_uint176_fail" ) => 2926152828 )
      
    
    rule  ( selector ( "test_uint184" ) => 2419331356 )
      
    
    rule  ( selector ( "test_uint184_fail" ) => 809918532 )
      
    
    rule  ( selector ( "test_uint192" ) => 126849335 )
      
    
    rule  ( selector ( "test_uint192_fail" ) => 965859284 )
      
    
    rule  ( selector ( "test_uint200" ) => 342308100 )
      
    
    rule  ( selector ( "test_uint200_fail" ) => 3554205475 )
      
    
    rule  ( selector ( "test_uint208" ) => 664969356 )
      
    
    rule  ( selector ( "test_uint208_fail" ) => 515244431 )
      
    
    rule  ( selector ( "test_uint216" ) => 2735221135 )
      
    
    rule  ( selector ( "test_uint216_fail" ) => 1244132421 )
      
    
    rule  ( selector ( "test_uint224" ) => 2791725032 )
      
    
    rule  ( selector ( "test_uint224_fail" ) => 3535210075 )
      
    
    rule  ( selector ( "test_uint232" ) => 2781872781 )
      
    
    rule  ( selector ( "test_uint232_fail" ) => 3352181217 )
      
    
    rule  ( selector ( "test_uint24" ) => 2865563805 )
      
    
    rule  ( selector ( "test_uint240" ) => 3274361055 )
      
    
    rule  ( selector ( "test_uint240_fail" ) => 4046179916 )
      
    
    rule  ( selector ( "test_uint248" ) => 578604507 )
      
    
    rule  ( selector ( "test_uint248_fail" ) => 3580188072 )
      
    
    rule  ( selector ( "test_uint24_fail" ) => 2328572638 )
      
    
    rule  ( selector ( "test_uint256" ) => 851358597 )
      
    
    rule  ( selector ( "test_uint256_fail" ) => 1895666222 )
      
    
    rule  ( selector ( "test_uint32" ) => 982223766 )
      
    
    rule  ( selector ( "test_uint32_fail" ) => 768917897 )
      
    
    rule  ( selector ( "test_uint40" ) => 1298765870 )
      
    
    rule  ( selector ( "test_uint40_fail" ) => 1685882915 )
      
    
    rule  ( selector ( "test_uint48" ) => 454435065 )
      
    
    rule  ( selector ( "test_uint48_fail" ) => 491533732 )
      
    
    rule  ( selector ( "test_uint56" ) => 58659965 )
      
    
    rule  ( selector ( "test_uint56_fail" ) => 3185974238 )
      
    
    rule  ( selector ( "test_uint64" ) => 2511119799 )
      
    
    rule  ( selector ( "test_uint64_fail" ) => 2000886247 )
      
    
    rule  ( selector ( "test_uint72" ) => 3694811120 )
      
    
    rule  ( selector ( "test_uint72_fail" ) => 875540037 )
      
    
    rule  ( selector ( "test_uint8" ) => 1704021016 )
      
    
    rule  ( selector ( "test_uint80" ) => 3841083967 )
      
    
    rule  ( selector ( "test_uint80_fail" ) => 3626141300 )
      
    
    rule  ( selector ( "test_uint88" ) => 100068129 )
      
    
    rule  ( selector ( "test_uint88_fail" ) => 318744457 )
      
    
    rule  ( selector ( "test_uint8_fail" ) => 2865005996 )
      
    
    rule  ( selector ( "test_uint96" ) => 1315861753 )
      
    
    rule  ( selector ( "test_uint96_fail" ) => 1635628195 )
      

endmodule

module VM-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= VmContract
    
    syntax VmContract ::= "Vm" [symbol(), klabel(contract_Vm)]
    
      
    
    syntax Bytes ::= VmContract "." VmMethod [function(), symbol(), klabel(method_Vm)]
    
    syntax VmMethod ::= "accesses" "(" Int ")" [symbol(), klabel(method_Vm_accesses)]
    
    syntax VmMethod ::= "activeFork" "(" ")" [symbol(), klabel(method_Vm_activeFork)]
    
    syntax VmMethod ::= "addr" "(" Int ")" [symbol(), klabel(method_Vm_addr)]
    
    syntax VmMethod ::= "assume" "(" Int ")" [symbol(), klabel(method_Vm_assume)]
    
    syntax VmMethod ::= "broadcast" "(" ")" [symbol(), klabel(method_Vm_broadcast)]
    
    syntax VmMethod ::= "broadcast" "(" ")" [symbol(), klabel(method_Vm_broadcast)]
    
    syntax VmMethod ::= "chainId" "(" Int ")" [symbol(), klabel(method_Vm_chainId)]
    
    syntax VmMethod ::= "clearMockedCalls" "(" ")" [symbol(), klabel(method_Vm_clearMockedCalls)]
    
    syntax VmMethod ::= "closeFile" "(" String ")" [symbol(), klabel(method_Vm_closeFile)]
    
    syntax VmMethod ::= "coinbase" "(" Int ")" [symbol(), klabel(method_Vm_coinbase)]
    
    syntax VmMethod ::= "createFork" "(" String ")" [symbol(), klabel(method_Vm_createFork)]
    
    syntax VmMethod ::= "createFork" "(" String ")" [symbol(), klabel(method_Vm_createFork)]
    
    syntax VmMethod ::= "createSelectFork" "(" String "," Int ")" [symbol(), klabel(method_Vm_createSelectFork)]
    
    syntax VmMethod ::= "createSelectFork" "(" String "," Int ")" [symbol(), klabel(method_Vm_createSelectFork)]
    
    syntax VmMethod ::= "deal" "(" Int "," Int ")" [symbol(), klabel(method_Vm_deal)]
    
    syntax VmMethod ::= "deriveKey" "(" String "," Int ")" [symbol(), klabel(method_Vm_deriveKey)]
    
    syntax VmMethod ::= "deriveKey" "(" String "," Int ")" [symbol(), klabel(method_Vm_deriveKey)]
    
    syntax VmMethod ::= "envAddress" "(" String ")" [symbol(), klabel(method_Vm_envAddress)]
    
    syntax VmMethod ::= "envAddress" "(" String ")" [symbol(), klabel(method_Vm_envAddress)]
    
    syntax VmMethod ::= "envBool" "(" String ")" [symbol(), klabel(method_Vm_envBool)]
    
    syntax VmMethod ::= "envBool" "(" String ")" [symbol(), klabel(method_Vm_envBool)]
    
    syntax VmMethod ::= "envBytes" "(" String ")" [symbol(), klabel(method_Vm_envBytes)]
    
    syntax VmMethod ::= "envBytes" "(" String ")" [symbol(), klabel(method_Vm_envBytes)]
    
    syntax VmMethod ::= "envBytes32" "(" String "," String ")" [symbol(), klabel(method_Vm_envBytes32)]
    
    syntax VmMethod ::= "envBytes32" "(" String "," String ")" [symbol(), klabel(method_Vm_envBytes32)]
    
    syntax VmMethod ::= "envInt" "(" String "," String ")" [symbol(), klabel(method_Vm_envInt)]
    
    syntax VmMethod ::= "envInt" "(" String "," String ")" [symbol(), klabel(method_Vm_envInt)]
    
    syntax VmMethod ::= "envString" "(" String "," String ")" [symbol(), klabel(method_Vm_envString)]
    
    syntax VmMethod ::= "envString" "(" String "," String ")" [symbol(), klabel(method_Vm_envString)]
    
    syntax VmMethod ::= "envUint" "(" String ")" [symbol(), klabel(method_Vm_envUint)]
    
    syntax VmMethod ::= "envUint" "(" String ")" [symbol(), klabel(method_Vm_envUint)]
    
    syntax VmMethod ::= "etch" "(" Int "," Bytes ")" [symbol(), klabel(method_Vm_etch)]
    
    syntax VmMethod ::= "expectCall" "(" Int "," Bytes ")" [symbol(), klabel(method_Vm_expectCall)]
    
    syntax VmMethod ::= "expectCall" "(" Int "," Bytes ")" [symbol(), klabel(method_Vm_expectCall)]
    
    syntax VmMethod ::= "expectEmit" "(" Int "," Int "," Int "," Int ")" [symbol(), klabel(method_Vm_expectEmit)]
    
    syntax VmMethod ::= "expectEmit" "(" Int "," Int "," Int "," Int ")" [symbol(), klabel(method_Vm_expectEmit)]
    
    syntax VmMethod ::= "expectRevert" "(" Int ")" [symbol(), klabel(method_Vm_expectRevert)]
    
    syntax VmMethod ::= "expectRevert" "(" Int ")" [symbol(), klabel(method_Vm_expectRevert)]
    
    syntax VmMethod ::= "expectRevert" "(" Int ")" [symbol(), klabel(method_Vm_expectRevert)]
    
    syntax VmMethod ::= "fee" "(" Int ")" [symbol(), klabel(method_Vm_fee)]
    
    syntax VmMethod ::= "ffi" "(" K ")" [symbol(), klabel(method_Vm_ffi)]
    
    syntax VmMethod ::= "getCode" "(" String ")" [symbol(), klabel(method_Vm_getCode)]
    
    syntax VmMethod ::= "getNonce" "(" Int ")" [symbol(), klabel(method_Vm_getNonce)]
    
    syntax VmMethod ::= "getRecordedLogs" "(" ")" [symbol(), klabel(method_Vm_getRecordedLogs)]
    
    syntax VmMethod ::= "label" "(" Int "," String ")" [symbol(), klabel(method_Vm_label)]
    
    syntax VmMethod ::= "load" "(" Int "," Int ")" [symbol(), klabel(method_Vm_load)]
    
    syntax VmMethod ::= "mockCall" "(" Int "," Int "," Bytes "," Bytes ")" [symbol(), klabel(method_Vm_mockCall)]
    
    syntax VmMethod ::= "mockCall" "(" Int "," Int "," Bytes "," Bytes ")" [symbol(), klabel(method_Vm_mockCall)]
    
    syntax VmMethod ::= "prank" "(" Int "," Int ")" [symbol(), klabel(method_Vm_prank)]
    
    syntax VmMethod ::= "prank" "(" Int "," Int ")" [symbol(), klabel(method_Vm_prank)]
    
    syntax VmMethod ::= "readFile" "(" String ")" [symbol(), klabel(method_Vm_readFile)]
    
    syntax VmMethod ::= "readLine" "(" String ")" [symbol(), klabel(method_Vm_readLine)]
    
    syntax VmMethod ::= "record" "(" ")" [symbol(), klabel(method_Vm_record)]
    
    syntax VmMethod ::= "recordLogs" "(" ")" [symbol(), klabel(method_Vm_recordLogs)]
    
    syntax VmMethod ::= "removeFile" "(" String ")" [symbol(), klabel(method_Vm_removeFile)]
    
    syntax VmMethod ::= "revertTo" "(" Int ")" [symbol(), klabel(method_Vm_revertTo)]
    
    syntax VmMethod ::= "roll" "(" Int ")" [symbol(), klabel(method_Vm_roll)]
    
    syntax VmMethod ::= "rollFork" "(" Int "," Int ")" [symbol(), klabel(method_Vm_rollFork)]
    
    syntax VmMethod ::= "rollFork" "(" Int "," Int ")" [symbol(), klabel(method_Vm_rollFork)]
    
    syntax VmMethod ::= "rpcUrl" "(" String ")" [symbol(), klabel(method_Vm_rpcUrl)]
    
    syntax VmMethod ::= "rpcUrls" "(" ")" [symbol(), klabel(method_Vm_rpcUrls)]
    
    syntax VmMethod ::= "selectFork" "(" Int ")" [symbol(), klabel(method_Vm_selectFork)]
    
    syntax VmMethod ::= "setEnv" "(" String "," String ")" [symbol(), klabel(method_Vm_setEnv)]
    
    syntax VmMethod ::= "setNonce" "(" Int "," Int ")" [symbol(), klabel(method_Vm_setNonce)]
    
    syntax VmMethod ::= "sign" "(" Int "," Int ")" [symbol(), klabel(method_Vm_sign)]
    
    syntax VmMethod ::= "snapshot" "(" ")" [symbol(), klabel(method_Vm_snapshot)]
    
    syntax VmMethod ::= "startBroadcast" "(" ")" [symbol(), klabel(method_Vm_startBroadcast)]
    
    syntax VmMethod ::= "startBroadcast" "(" ")" [symbol(), klabel(method_Vm_startBroadcast)]
    
    syntax VmMethod ::= "startPrank" "(" Int ")" [symbol(), klabel(method_Vm_startPrank)]
    
    syntax VmMethod ::= "startPrank" "(" Int ")" [symbol(), klabel(method_Vm_startPrank)]
    
    syntax VmMethod ::= "stopBroadcast" "(" ")" [symbol(), klabel(method_Vm_stopBroadcast)]
    
    syntax VmMethod ::= "stopPrank" "(" ")" [symbol(), klabel(method_Vm_stopPrank)]
    
    syntax VmMethod ::= "store" "(" Int "," Int "," Int ")" [symbol(), klabel(method_Vm_store)]
    
    syntax VmMethod ::= "toString" "(" Int ")" [symbol(), klabel(method_Vm_toString)]
    
    syntax VmMethod ::= "toString" "(" Int ")" [symbol(), klabel(method_Vm_toString)]
    
    syntax VmMethod ::= "toString" "(" Int ")" [symbol(), klabel(method_Vm_toString)]
    
    syntax VmMethod ::= "toString" "(" Int ")" [symbol(), klabel(method_Vm_toString)]
    
    syntax VmMethod ::= "toString" "(" Int ")" [symbol(), klabel(method_Vm_toString)]
    
    syntax VmMethod ::= "toString" "(" Int ")" [symbol(), klabel(method_Vm_toString)]
    
    syntax VmMethod ::= "warp" "(" Int ")" [symbol(), klabel(method_Vm_warp)]
    
    syntax VmMethod ::= "writeFile" "(" String "," String ")" [symbol(), klabel(method_Vm_writeFile)]
    
    syntax VmMethod ::= "writeLine" "(" String "," String ")" [symbol(), klabel(method_Vm_writeLine)]
    
    rule  ( Vm . accesses ( V0_ ) => #abiCallData ( "accesses" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( Vm . activeFork ( ) => #abiCallData ( "activeFork" , .TypedArgs ) )
      
    
    rule  ( Vm . addr ( V0_ ) => #abiCallData ( "addr" , #uint256 ( V0_ ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_ )
      
    
    rule  ( Vm . assume ( V0_ ) => #abiCallData ( "assume" , #bool ( V0_ ) , .TypedArgs ) )
       ensures #rangeBool ( V0_ )
      
    
    rule  ( Vm . broadcast ( ) => #abiCallData ( "broadcast" , .TypedArgs ) )
      
    
    rule  ( Vm . broadcast ( ) => #abiCallData ( "broadcast" , .TypedArgs ) )
      
    
    rule  ( Vm . chainId ( V0_ ) => #abiCallData ( "chainId" , #uint256 ( V0_ ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_ )
      
    
    rule  ( Vm . clearMockedCalls ( ) => #abiCallData ( "clearMockedCalls" , .TypedArgs ) )
      
    
    rule  ( Vm . closeFile ( V0_ ) => #abiCallData ( "closeFile" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . coinbase ( V0_ ) => #abiCallData ( "coinbase" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( Vm . createFork ( V0_ ) => #abiCallData ( "createFork" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . createFork ( V0_ ) => #abiCallData ( "createFork" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . createSelectFork ( V0_ , V1_ ) => #abiCallData ( "createSelectFork" , #string ( V0_ ) , #uint256 ( V1_ ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V1_ )
      
    
    rule  ( Vm . createSelectFork ( V0_ , V1_ ) => #abiCallData ( "createSelectFork" , #string ( V0_ ) , #uint256 ( V1_ ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V1_ )
      
    
    rule  ( Vm . deal ( V0_ , V1_ ) => #abiCallData ( "deal" , #address ( V0_ ) , #uint256 ( V1_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 256 , V1_ )
               ))
      
    
    rule  ( Vm . deriveKey ( V0_ , V1_ ) => #abiCallData ( "deriveKey" , #string ( V0_ ) , #uint32 ( V1_ ) , .TypedArgs ) )
       ensures #rangeUInt ( 32 , V1_ )
      
    
    rule  ( Vm . deriveKey ( V0_ , V1_ ) => #abiCallData ( "deriveKey" , #string ( V0_ ) , #uint32 ( V1_ ) , .TypedArgs ) )
       ensures #rangeUInt ( 32 , V1_ )
      
    
    rule  ( Vm . envAddress ( V0_ ) => #abiCallData ( "envAddress" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envAddress ( V0_ ) => #abiCallData ( "envAddress" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envBool ( V0_ ) => #abiCallData ( "envBool" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envBool ( V0_ ) => #abiCallData ( "envBool" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envBytes ( V0_ ) => #abiCallData ( "envBytes" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envBytes ( V0_ ) => #abiCallData ( "envBytes" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envBytes32 ( V0_ , V1_ ) => #abiCallData ( "envBytes32" , #string ( V0_ ) , #string ( V1_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envBytes32 ( V0_ , V1_ ) => #abiCallData ( "envBytes32" , #string ( V0_ ) , #string ( V1_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envInt ( V0_ , V1_ ) => #abiCallData ( "envInt" , #string ( V0_ ) , #string ( V1_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envInt ( V0_ , V1_ ) => #abiCallData ( "envInt" , #string ( V0_ ) , #string ( V1_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envString ( V0_ , V1_ ) => #abiCallData ( "envString" , #string ( V0_ ) , #string ( V1_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envString ( V0_ , V1_ ) => #abiCallData ( "envString" , #string ( V0_ ) , #string ( V1_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envUint ( V0_ ) => #abiCallData ( "envUint" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . envUint ( V0_ ) => #abiCallData ( "envUint" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . etch ( V0_ , V1_ ) => #abiCallData ( "etch" , #address ( V0_ ) , #bytes ( V1_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V1_ ) )
               ))
      
    
    rule  ( Vm . expectCall ( V0_ , V1_ ) => #abiCallData ( "expectCall" , #address ( V0_ ) , #bytes ( V1_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V1_ ) )
               ))
      
    
    rule  ( Vm . expectCall ( V0_ , V1_ ) => #abiCallData ( "expectCall" , #address ( V0_ ) , #bytes ( V1_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V1_ ) )
               ))
      
    
    rule  ( Vm . expectEmit ( V0_ , V1_ , V2_ , V3_ ) => #abiCallData ( "expectEmit" , #bool ( V0_ ) , #bool ( V1_ ) , #bool ( V2_ ) , #bool ( V3_ ) , .TypedArgs ) )
       ensures ( #rangeBool ( V0_ )
       andBool ( #rangeBool ( V1_ )
       andBool ( #rangeBool ( V2_ )
       andBool ( #rangeBool ( V3_ )
               ))))
      
    
    rule  ( Vm . expectEmit ( V0_ , V1_ , V2_ , V3_ ) => #abiCallData ( "expectEmit" , #bool ( V0_ ) , #bool ( V1_ ) , #bool ( V2_ ) , #bool ( V3_ ) , .TypedArgs ) )
       ensures ( #rangeBool ( V0_ )
       andBool ( #rangeBool ( V1_ )
       andBool ( #rangeBool ( V2_ )
       andBool ( #rangeBool ( V3_ )
               ))))
      
    
    rule  ( Vm . expectRevert ( V0_ ) => #abiCallData ( "expectRevert" , #bytes4 ( V0_ ) , .TypedArgs ) )
       ensures #rangeBytes ( 4 , V0_ )
      
    
    rule  ( Vm . expectRevert ( V0_ ) => #abiCallData ( "expectRevert" , #bytes4 ( V0_ ) , .TypedArgs ) )
       ensures #rangeBytes ( 4 , V0_ )
      
    
    rule  ( Vm . expectRevert ( V0_ ) => #abiCallData ( "expectRevert" , #bytes4 ( V0_ ) , .TypedArgs ) )
       ensures #rangeBytes ( 4 , V0_ )
      
    
    rule  ( Vm . fee ( V0_ ) => #abiCallData ( "fee" , #uint256 ( V0_ ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_ )
      
    
    rule  ( Vm . getCode ( V0_ ) => #abiCallData ( "getCode" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . getNonce ( V0_ ) => #abiCallData ( "getNonce" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( Vm . getRecordedLogs ( ) => #abiCallData ( "getRecordedLogs" , .TypedArgs ) )
      
    
    rule  ( Vm . label ( V0_ , V1_ ) => #abiCallData ( "label" , #address ( V0_ ) , #string ( V1_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( Vm . load ( V0_ , V1_ ) => #abiCallData ( "load" , #address ( V0_ ) , #bytes32 ( V1_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 256 , V1_ )
               ))
      
    
    rule  ( Vm . mockCall ( V0_ , V1_ , V2_ , V3_ ) => #abiCallData ( "mockCall" , #address ( V0_ ) , #uint256 ( V1_ ) , #bytes ( V2_ ) , #bytes ( V3_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 256 , V1_ )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V2_ ) )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V3_ ) )
               ))))
      
    
    rule  ( Vm . mockCall ( V0_ , V1_ , V2_ , V3_ ) => #abiCallData ( "mockCall" , #address ( V0_ ) , #uint256 ( V1_ ) , #bytes ( V2_ ) , #bytes ( V3_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 256 , V1_ )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V2_ ) )
       andBool ( #rangeUInt ( 128 , lengthBytes ( V3_ ) )
               ))))
      
    
    rule  ( Vm . prank ( V0_ , V1_ ) => #abiCallData ( "prank" , #address ( V0_ ) , #address ( V1_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeAddress ( V1_ )
               ))
      
    
    rule  ( Vm . prank ( V0_ , V1_ ) => #abiCallData ( "prank" , #address ( V0_ ) , #address ( V1_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeAddress ( V1_ )
               ))
      
    
    rule  ( Vm . readFile ( V0_ ) => #abiCallData ( "readFile" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . readLine ( V0_ ) => #abiCallData ( "readLine" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . record ( ) => #abiCallData ( "record" , .TypedArgs ) )
      
    
    rule  ( Vm . recordLogs ( ) => #abiCallData ( "recordLogs" , .TypedArgs ) )
      
    
    rule  ( Vm . removeFile ( V0_ ) => #abiCallData ( "removeFile" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . revertTo ( V0_ ) => #abiCallData ( "revertTo" , #uint256 ( V0_ ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_ )
      
    
    rule  ( Vm . roll ( V0_ ) => #abiCallData ( "roll" , #uint256 ( V0_ ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_ )
      
    
    rule  ( Vm . rollFork ( V0_forkId , V1_blockNumber ) => #abiCallData ( "rollFork" , #uint256 ( V0_forkId ) , #uint256 ( V1_blockNumber ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_forkId )
       andBool ( #rangeUInt ( 256 , V1_blockNumber )
               ))
      
    
    rule  ( Vm . rollFork ( V0_forkId , V1_blockNumber ) => #abiCallData ( "rollFork" , #uint256 ( V0_forkId ) , #uint256 ( V1_blockNumber ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_forkId )
       andBool ( #rangeUInt ( 256 , V1_blockNumber )
               ))
      
    
    rule  ( Vm . rpcUrl ( V0_ ) => #abiCallData ( "rpcUrl" , #string ( V0_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . rpcUrls ( ) => #abiCallData ( "rpcUrls" , .TypedArgs ) )
      
    
    rule  ( Vm . selectFork ( V0_ ) => #abiCallData ( "selectFork" , #uint256 ( V0_ ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_ )
      
    
    rule  ( Vm . setEnv ( V0_ , V1_ ) => #abiCallData ( "setEnv" , #string ( V0_ ) , #string ( V1_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . setNonce ( V0_ , V1_ ) => #abiCallData ( "setNonce" , #address ( V0_ ) , #uint64 ( V1_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 64 , V1_ )
               ))
      
    
    rule  ( Vm . sign ( V0_ , V1_ ) => #abiCallData ( "sign" , #uint256 ( V0_ ) , #bytes32 ( V1_ ) , .TypedArgs ) )
       ensures ( #rangeUInt ( 256 , V0_ )
       andBool ( #rangeUInt ( 256 , V1_ )
               ))
      
    
    rule  ( Vm . snapshot ( ) => #abiCallData ( "snapshot" , .TypedArgs ) )
      
    
    rule  ( Vm . startBroadcast ( ) => #abiCallData ( "startBroadcast" , .TypedArgs ) )
      
    
    rule  ( Vm . startBroadcast ( ) => #abiCallData ( "startBroadcast" , .TypedArgs ) )
      
    
    rule  ( Vm . startPrank ( V0_ ) => #abiCallData ( "startPrank" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( Vm . startPrank ( V0_ ) => #abiCallData ( "startPrank" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( Vm . stopBroadcast ( ) => #abiCallData ( "stopBroadcast" , .TypedArgs ) )
      
    
    rule  ( Vm . stopPrank ( ) => #abiCallData ( "stopPrank" , .TypedArgs ) )
      
    
    rule  ( Vm . store ( V0_ , V1_ , V2_ ) => #abiCallData ( "store" , #address ( V0_ ) , #bytes32 ( V1_ ) , #bytes32 ( V2_ ) , .TypedArgs ) )
       ensures ( #rangeAddress ( V0_ )
       andBool ( #rangeUInt ( 256 , V1_ )
       andBool ( #rangeUInt ( 256 , V2_ )
               )))
      
    
    rule  ( Vm . toString ( V0_ ) => #abiCallData ( "toString" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( Vm . toString ( V0_ ) => #abiCallData ( "toString" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( Vm . toString ( V0_ ) => #abiCallData ( "toString" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( Vm . toString ( V0_ ) => #abiCallData ( "toString" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( Vm . toString ( V0_ ) => #abiCallData ( "toString" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( Vm . toString ( V0_ ) => #abiCallData ( "toString" , #address ( V0_ ) , .TypedArgs ) )
       ensures #rangeAddress ( V0_ )
      
    
    rule  ( Vm . warp ( V0_ ) => #abiCallData ( "warp" , #uint256 ( V0_ ) , .TypedArgs ) )
       ensures #rangeUInt ( 256 , V0_ )
      
    
    rule  ( Vm . writeFile ( V0_ , V1_ ) => #abiCallData ( "writeFile" , #string ( V0_ ) , #string ( V1_ ) , .TypedArgs ) )
      
    
    rule  ( Vm . writeLine ( V0_ , V1_ ) => #abiCallData ( "writeLine" , #string ( V0_ ) , #string ( V1_ ) , .TypedArgs ) )
      
    
    rule  ( selector ( "accesses" ) => 1706857601 )
      
    
    rule  ( selector ( "activeFork" ) => 789593890 )
      
    
    rule  ( selector ( "addr" ) => 4288775753 )
      
    
    rule  ( selector ( "assume" ) => 1281615202 )
      
    
    rule  ( selector ( "broadcast" ) => 2949218368 )
      
    
    rule  ( selector ( "broadcast" ) => 3868601563 )
      
    
    rule  ( selector ( "chainId" ) => 1078582738 )
      
    
    rule  ( selector ( "clearMockedCalls" ) => 1071599125 )
      
    
    rule  ( selector ( "closeFile" ) => 1220748319 )
      
    
    rule  ( selector ( "coinbase" ) => 4282924116 )
      
    
    rule  ( selector ( "createFork" ) => 834286744 )
      
    
    rule  ( selector ( "createFork" ) => 1805892139 )
      
    
    rule  ( selector ( "createSelectFork" ) => 2556952628 )
      
    
    rule  ( selector ( "createSelectFork" ) => 1911440973 )
      
    
    rule  ( selector ( "deal" ) => 3364511341 )
      
    
    rule  ( selector ( "deriveKey" ) => 1808477211 )
      
    
    rule  ( selector ( "deriveKey" ) => 1646872971 )
      
    
    rule  ( selector ( "envAddress" ) => 890066623 )
      
    
    rule  ( selector ( "envAddress" ) => 2905717242 )
      
    
    rule  ( selector ( "envBool" ) => 2127686781 )
      
    
    rule  ( selector ( "envBool" ) => 2863521455 )
      
    
    rule  ( selector ( "envBytes" ) => 1299951366 )
      
    
    rule  ( selector ( "envBytes" ) => 3720504603 )
      
    
    rule  ( selector ( "envBytes32" ) => 2543095874 )
      
    
    rule  ( selector ( "envBytes32" ) => 1525821889 )
      
    
    rule  ( selector ( "envInt" ) => 2301234273 )
      
    
    rule  ( selector ( "envInt" ) => 1108873552 )
      
    
    rule  ( selector ( "envString" ) => 4168600345 )
      
    
    rule  ( selector ( "envString" ) => 347089865 )
      
    
    rule  ( selector ( "envUint" ) => 3247934751 )
      
    
    rule  ( selector ( "envUint" ) => 4091461785 )
      
    
    rule  ( selector ( "etch" ) => 3033974658 )
      
    
    rule  ( selector ( "expectCall" ) => 3177903156 )
      
    
    rule  ( selector ( "expectCall" ) => 4077681571 )
      
    
    rule  ( selector ( "expectEmit" ) => 1226622914 )
      
    
    rule  ( selector ( "expectEmit" ) => 2176505587 )
      
    
    rule  ( selector ( "expectRevert" ) => 4102309908 )
      
    
    rule  ( selector ( "expectRevert" ) => 4069379763 )
      
    
    rule  ( selector ( "expectRevert" ) => 3273568480 )
      
    
    rule  ( selector ( "fee" ) => 968063664 )
      
    
    rule  ( selector ( "ffi" ) => 2299921511 )
      
    
    rule  ( selector ( "getCode" ) => 2367473957 )
      
    
    rule  ( selector ( "getNonce" ) => 755185067 )
      
    
    rule  ( selector ( "getRecordedLogs" ) => 420828068 )
      
    
    rule  ( selector ( "label" ) => 3327641368 )
      
    
    rule  ( selector ( "load" ) => 1719639408 )
      
    
    rule  ( selector ( "mockCall" ) => 3110212580 )
      
    
    rule  ( selector ( "mockCall" ) => 2168494993 )
      
    
    rule  ( selector ( "prank" ) => 3395723175 )
      
    
    rule  ( selector ( "prank" ) => 1206193358 )
      
    
    rule  ( selector ( "readFile" ) => 1626979089 )
      
    
    rule  ( selector ( "readLine" ) => 1895126824 )
      
    
    rule  ( selector ( "record" ) => 644673801 )
      
    
    rule  ( selector ( "recordLogs" ) => 1101999954 )
      
    
    rule  ( selector ( "removeFile" ) => 4054835277 )
      
    
    rule  ( selector ( "revertTo" ) => 1155002532 )
      
    
    rule  ( selector ( "roll" ) => 528174896 )
      
    
    rule  ( selector ( "rollFork" ) => 3652973473 )
      
    
    rule  ( selector ( "rollFork" ) => 3612115876 )
      
    
    rule  ( selector ( "rpcUrl" ) => 2539285737 )
      
    
    rule  ( selector ( "rpcUrls" ) => 2824504344 )
      
    
    rule  ( selector ( "selectFork" ) => 2663344167 )
      
    
    rule  ( selector ( "setEnv" ) => 1029252078 )
      
    
    rule  ( selector ( "setNonce" ) => 4175530839 )
      
    
    rule  ( selector ( "sign" ) => 3812747940 )
      
    
    rule  ( selector ( "snapshot" ) => 2534502746 )
      
    
    rule  ( selector ( "startBroadcast" ) => 2142579071 )
      
    
    rule  ( selector ( "startBroadcast" ) => 2146183821 )
      
    
    rule  ( selector ( "startPrank" ) => 105151830 )
      
    
    rule  ( selector ( "startPrank" ) => 1169514616 )
      
    
    rule  ( selector ( "stopBroadcast" ) => 1995103542 )
      
    
    rule  ( selector ( "stopPrank" ) => 2428830011 )
      
    
    rule  ( selector ( "store" ) => 1892290747 )
      
    
    rule  ( selector ( "toString" ) => 1456103998 )
      
    
    rule  ( selector ( "toString" ) => 1910302682 )
      
    
    rule  ( selector ( "toString" ) => 1907020045 )
      
    
    rule  ( selector ( "toString" ) => 2971277800 )
      
    
    rule  ( selector ( "toString" ) => 2736964622 )
      
    
    rule  ( selector ( "toString" ) => 1761649582 )
      
    
    rule  ( selector ( "warp" ) => 3856056066 )
      
    
    rule  ( selector ( "writeFile" ) => 2306738839 )
      
    
    rule  ( selector ( "writeLine" ) => 1637714303 )
      

endmodule

module CONSOLE-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= ConsoleContract
    
    syntax ConsoleContract ::= "console" [symbol(), klabel(contract_console)]
    
      

endmodule

module CONSOLE2-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= Console2Contract
    
    syntax Console2Contract ::= "console2" [symbol(), klabel(contract_console2)]
    
      

endmodule

module DSTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    syntax Contract ::= DSTestContract
    
    syntax DSTestContract ::= "DSTest" [symbol(), klabel(contract_DSTest)]
    
      
    
    syntax Field ::= DSTestField
    
    syntax DSTestField ::= "IS_TEST" [symbol(), klabel(field_DSTest_IS_TEST)]
    
    syntax DSTestField ::= "_failed" [symbol(), klabel(field_DSTest__failed)]
    
    rule  ( #loc ( DSTest . IS_TEST ) => 0 )
      
    
    rule  ( #loc ( DSTest . _failed ) => 0 )
      
    
    syntax Bytes ::= DSTestContract "." DSTestMethod [function(), symbol(), klabel(method_DSTest)]
    
    syntax DSTestMethod ::= "IS_TEST" "(" ")" [symbol(), klabel(method_DSTest_IS_TEST)]
    
    syntax DSTestMethod ::= "failed" "(" ")" [symbol(), klabel(method_DSTest_failed)]
    
    rule  ( DSTest . IS_TEST ( ) => #abiCallData ( "IS_TEST" , .TypedArgs ) )
      
    
    rule  ( DSTest . failed ( ) => #abiCallData ( "failed" , .TypedArgs ) )
      
    
    rule  ( selector ( "IS_TEST" ) => 4202047188 )
      
    
    rule  ( selector ( "failed" ) => 3124842406 )
      

endmodule

module FOUNDRY-MAIN
    imports public ACCOUNTPARAMSTEST-BIN-RUNTIME
    imports public ADDRTEST-BIN-RUNTIME
    imports public ALLOWCHANGESTEST-BIN-RUNTIME
    imports public VALUESTORE-BIN-RUNTIME
    imports public ARITHMETICTEST-BIN-RUNTIME
    imports public ASSUMETEST-BIN-RUNTIME
    imports public BLOCKPARAMSTEST-BIN-RUNTIME
    imports public BROADCASTTEST-BIN-RUNTIME
    imports public CONSTANTS-BIN-RUNTIME
    imports public CONTRACT-BIN-RUNTIME
    imports public CONTRACTTEST-BIN-RUNTIME
    imports public CONTRACTBTEST-BIN-RUNTIME
    imports public COUNTER-BIN-RUNTIME
    imports public COUNTERTEST-BIN-RUNTIME
    imports public DYNAMICTYPES-BIN-RUNTIME
    imports public EXPECTEMIT-BIN-RUNTIME
    imports public EMITCONTRACTTEST-BIN-RUNTIME
    imports public ENVTEST-BIN-RUNTIME
    imports public DUMMY-BIN-RUNTIME
    imports public EXPECTCALLTEST-BIN-RUNTIME
    imports public DEPTHREVERTER-BIN-RUNTIME
    imports public EXPECTREVERTTEST-BIN-RUNTIME
    imports public REVERTER-BIN-RUNTIME
    imports public REVERTERWITHRETURN-BIN-RUNTIME
    imports public FFITEST-BIN-RUNTIME
    imports public FILESTEST-BIN-RUNTIME
    imports public FORKTEST-BIN-RUNTIME
    imports public GASTEST-BIN-RUNTIME
    imports public GETCODETEST-BIN-RUNTIME
    imports public KEVMCHEATS-BIN-RUNTIME
    imports public KEVMCHEATSBASE-BIN-RUNTIME
    imports public LABELTEST-BIN-RUNTIME
    imports public LOOPSTEST-BIN-RUNTIME
    imports public MOCKCALLTEST-BIN-RUNTIME
    imports public MYIERC20-BIN-RUNTIME
    imports public MYTOKEN-BIN-RUNTIME
    imports public NOIMPORT-BIN-RUNTIME
    imports public OWNERUPONLY-BIN-RUNTIME
    imports public OWNERUPONLYTEST-BIN-RUNTIME
    imports public ADDITIONALTOKEN-BIN-RUNTIME
    imports public PLAINPRANKTEST-BIN-RUNTIME
    imports public PRANK-BIN-RUNTIME
    imports public PRANKTEST-BIN-RUNTIME
    imports public RECORDLOGSTEST-BIN-RUNTIME
    imports public SAFE-BIN-RUNTIME
    imports public SAFETEST-BIN-RUNTIME
    imports public SCRIPT-BIN-RUNTIME
    imports public SETUP2TEST-BIN-RUNTIME
    imports public SETUPTEST-BIN-RUNTIME
    imports public SIGNTEST-BIN-RUNTIME
    imports public ASSERTTEST-BIN-RUNTIME
    imports public SNAPSHOTTEST-BIN-RUNTIME
    imports public STORE-BIN-RUNTIME
    imports public STORETEST-BIN-RUNTIME
    imports public SYMBOLICSTORAGETEST-BIN-RUNTIME
    imports public SYMBOLICSTORE-BIN-RUNTIME
    imports public TEST-BIN-RUNTIME
    imports public STDERROR-BIN-RUNTIME
    imports public STDMATH-BIN-RUNTIME
    imports public STDSTORAGE-BIN-RUNTIME
    imports public TESTNUMBER-BIN-RUNTIME
    imports public TOSTRINGTEST-BIN-RUNTIME
    imports public TOKEN-BIN-RUNTIME
    imports public BYTESTYPETEST-BIN-RUNTIME
    imports public UINTTYPETEST-BIN-RUNTIME
    imports public VM-BIN-RUNTIME
    imports public CONSOLE-BIN-RUNTIME
    imports public CONSOLE2-BIN-RUNTIME
    imports public DSTEST-BIN-RUNTIME
    imports public FOUNDRY
    
    

endmodule
